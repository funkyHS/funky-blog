(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{467:function(o,r,e){"use strict";e.r(r);var n=e(45),a=Object(n.a)({},(function(){var o=this,r=o.$createElement,e=o._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#_1-基础知识"}},[o._v("1. 基础知识")]),e("ul",[e("li",[e("a",{attrs:{href:"#如果没有runloop"}},[o._v("如果没有RunLoop")])]),e("li",[e("a",{attrs:{href:"#如果有runloop"}},[o._v("如果有Runloop")])]),e("li",[e("a",{attrs:{href:"#main函数中的runloop"}},[o._v("main函数中的RunLoop")])]),e("li",[e("a",{attrs:{href:"#runloop作用"}},[o._v("Runloop作用")])])])]),e("li",[e("a",{attrs:{href:"#_2-runloop对象"}},[o._v("2. RunLoop对象")]),e("ul",[e("li",[e("a",{attrs:{href:"#ios中有2套api来访问和使用runloop"}},[o._v("iOS中有2套API来访问和使用RunLoop")])])])]),e("li",[e("a",{attrs:{href:"#_3-runloop与线程"}},[o._v("3. RunLoop与线程")])]),e("li",[e("a",{attrs:{href:"#_4-获得runloop对象"}},[o._v("4. 获得RunLoop对象")])]),e("li",[e("a",{attrs:{href:"#_5-runloop相关类"}},[o._v("5. RunLoop相关类")]),e("ul",[e("li",[e("a",{attrs:{href:"#core-foundation中关于runloop的5个类"}},[o._v("Core Foundation中关于RunLoop的5个类")])]),e("li",[e("a",{attrs:{href:"#cfrunloopmoderef"}},[o._v("CFRunLoopModeRef")])]),e("li",[e("a",{attrs:{href:"#cfrunloopsourceref"}},[o._v("CFRunLoopSourceRef")])]),e("li",[e("a",{attrs:{href:"#cfrunlooptimerref"}},[o._v("CFRunLoopTimerRef")])]),e("li",[e("a",{attrs:{href:"#cfrunloopobserverref"}},[o._v("CFRunLoopObserverRef")])])])]),e("li",[e("a",{attrs:{href:"#_6-runloop处理逻辑"}},[o._v("6. RunLoop处理逻辑")])]),e("li",[e("a",{attrs:{href:"#_7-自动释放池与runloop"}},[o._v("7. 自动释放池与RunLoop")])]),e("li",[e("a",{attrs:{href:"#_8-视频学习记录"}},[o._v("8. 视频学习记录")]),e("ul",[e("li",[e("a",{attrs:{href:"#为什么点击屏幕会唤醒runloop"}},[o._v("为什么点击屏幕会唤醒RunLoop？")])]),e("li",[e("a",{attrs:{href:"#可以唤醒runloop的事件"}},[o._v("可以唤醒Runloop的事件")])])])]),e("li",[e("a",{attrs:{href:"#_9-runloop的mode是如何切换的-runloop的mode切换时-上一个mode是需要退出吗"}},[o._v("9. Runloop的mode是如何切换的？Runloop的mode切换时，上一个mode是需要退出吗？")])])])]),e("p"),o._v(" "),e("h1",{attrs:{id:"runloop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#runloop"}},[o._v("#")]),o._v(" Runloop")]),o._v(" "),e("h2",{attrs:{id:"_1-基础知识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-基础知识"}},[o._v("#")]),o._v(" 1. 基础知识")]),o._v(" "),e("h3",{attrs:{id:"如果没有runloop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如果没有runloop"}},[o._v("#")]),o._v(" 如果没有RunLoop")]),o._v(" "),e("h3",{attrs:{id:"如果有runloop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如果有runloop"}},[o._v("#")]),o._v(" 如果有Runloop")]),o._v(" "),e("h3",{attrs:{id:"main函数中的runloop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#main函数中的runloop"}},[o._v("#")]),o._v(" main函数中的RunLoop")]),o._v(" "),e("ul",[e("li",[o._v("UIApplicationMain函数内部就启动了一个RunLoop，所以UIApplicationMain函数一直没有返回，保持了程序的持续运行")]),o._v(" "),e("li",[o._v("这个默认启动的RunLoop是跟主线程相关联的")])]),o._v(" "),e("h3",{attrs:{id:"runloop作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#runloop作用"}},[o._v("#")]),o._v(" Runloop作用")]),o._v(" "),e("ul",[e("li",[o._v("保持程序的持续运行")]),o._v(" "),e("li",[o._v("处理app中的各种事件（比如触摸事件、定时器事件【NSTimer】、selector事件【选择器performSelector···】）")]),o._v(" "),e("li",[o._v("节省CPU资源，提高程序性能，有事情就做事情，没事情就休息")])]),o._v(" "),e("h2",{attrs:{id:"_2-runloop对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-runloop对象"}},[o._v("#")]),o._v(" 2. RunLoop对象")]),o._v(" "),e("h3",{attrs:{id:"ios中有2套api来访问和使用runloop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ios中有2套api来访问和使用runloop"}},[o._v("#")]),o._v(" iOS中有2套API来访问和使用RunLoop")]),o._v(" "),e("ul",[e("li",[o._v("Foundation：NSRunLoop")]),o._v(" "),e("li",[o._v("Core Foundation：CFRunLoopRef")]),o._v(" "),e("li",[o._v("NSRunLoop和CFRunLoopRef都代表着RunLoop对象，NSRunLoop是基于CFRunLoopRef的一层OC包装，所以要了解RunLoop内部结构，需要多研究CFRunLoopRef层面的API（Core Foundation层面）")])]),o._v(" "),e("h2",{attrs:{id:"_3-runloop与线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-runloop与线程"}},[o._v("#")]),o._v(" 3. RunLoop与线程")]),o._v(" "),e("ul",[e("li",[o._v("每条线程都有唯一的一个与之对应的RunLoop对象")]),o._v(" "),e("li",[o._v("如何让子线程不死：给这条子线程开启一个Runloop")]),o._v(" "),e("li",[o._v("主线程的RunLoop已经自动创建好了，子线程的RunLoop需要主动创建，如果不主动获取Runloop的话，那么子线程内部是不会创建Runloop的。可以下载CFRunloopRef的源码，搜索_CFRunloopGet0,查看代码")]),o._v(" "),e("li",[o._v("Runloop的生命周期：RunLoop在第一次获取时创建，在线程结束时销毁")]),o._v(" "),e("li",[o._v("Runloop对象是利用字典来进行存储，而且key是对应的线程Value为该线程对应的Runloop。")])]),o._v(" "),e("h2",{attrs:{id:"_4-获得runloop对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-获得runloop对象"}},[o._v("#")]),o._v(" 4. 获得RunLoop对象")]),o._v(" "),e("div",{staticClass:"language-oc extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v("// Foundation\n[NSRunLoop currentRunLoop];  // 获得当前线程的RunLoop对象\n[NSRunLoop mainRunLoop];       // 获得主线程的RunLoop对象\n\n// Core Foundation\nCFRunLoopGetCurrent();  // 获得当前线程的RunLoop对象\nCFRunLoopGetMain();     // 获得主线程的RunLoop对象 \n")])])]),e("h2",{attrs:{id:"_5-runloop相关类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-runloop相关类"}},[o._v("#")]),o._v(" 5. RunLoop相关类")]),o._v(" "),e("h3",{attrs:{id:"core-foundation中关于runloop的5个类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#core-foundation中关于runloop的5个类"}},[o._v("#")]),o._v(" Core Foundation中关于RunLoop的5个类")]),o._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[o._v("- CFRunLoopRef:它自己,也就代表一个RunLoop对象\n- CFRunLoopModeRef :RunLoop的运行模式\n- CFRunLoopSourceRef :事件源\n- CFRunLoopTimerRef :时间的触发器\n- CFRunLoopObserverRef :观察者 监听CFRunLoopRef的状态改变\n")])])]),e("h3",{attrs:{id:"cfrunloopmoderef"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cfrunloopmoderef"}},[o._v("#")]),o._v(" CFRunLoopModeRef")]),o._v(" "),e("ul",[e("li",[o._v("CFRunLoopModeRef代表RunLoop的运行模式")]),o._v(" "),e("li",[o._v("一个 RunLoop 包含若干个 Mode，每个Mode又包含若干个Source/Timer/Observer")]),o._v(" "),e("li",[o._v("每次RunLoop启动时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode")]),o._v(" "),e("li",[o._v("如果需要切换Mode，只能退出Loop，再重新指定一个Mode进入，这样做主要是为了分隔开不同组的Source/Timer/Observer，让其互不影响")]),o._v(" "),e("li",[o._v("系统默认注册了5个Mode模式:\n"),e("ul",[e("li",[e("code",[o._v("kCFRunLoopDefaultMode")]),o._v("：App的默认Mode，通常主线程是在这个Mode下运行")]),o._v(" "),e("li",[e("code",[o._v("UITrackingRunLoopMode")]),o._v("：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响")]),o._v(" "),e("li",[e("code",[o._v("UIInitializationRunLoopMode")]),o._v(": 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用")]),o._v(" "),e("li",[e("code",[o._v("GSEventReceiveRunLoopMode")]),o._v(": 接受系统事件的内部 Mode，通常用不到")]),o._v(" "),e("li",[e("code",[o._v("kCFRunLoopCommonModes")]),o._v(": 这是一个占位用的Mode，不是一种真正的Mode")])])])]),o._v(" "),e("h3",{attrs:{id:"cfrunloopsourceref"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cfrunloopsourceref"}},[o._v("#")]),o._v(" CFRunLoopSourceRef")]),o._v(" "),e("ul",[e("li",[o._v("CFRunLoopSourceRef是事件源（输入源）")]),o._v(" "),e("li",[o._v("以前的分法： Port-Based Sources、Custom Input Sources、Cocoa Perform Selector Sources")]),o._v(" "),e("li",[o._v("现在的分法：\n"),e("ul",[e("li",[o._v("Source0：不基于Port的（用户主动触发的事件）")]),o._v(" "),e("li",[o._v("Source1：基于Port的（系统内部的消息事件）")])])]),o._v(" "),e("li",[o._v("(Port是线程间通信的一种方式，如果两个线程之间想通信，可以通过Port来通信。)")])]),o._v(" "),e("h3",{attrs:{id:"cfrunlooptimerref"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cfrunlooptimerref"}},[o._v("#")]),o._v(" CFRunLoopTimerRef")]),o._v(" "),e("ul",[e("li",[o._v("CFRunLoopTimerRef是基于时间的触发器，基本上说的就是NSTimer")])]),o._v(" "),e("h3",{attrs:{id:"cfrunloopobserverref"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cfrunloopobserverref"}},[o._v("#")]),o._v(" CFRunLoopObserverRef")]),o._v(" "),e("ul",[e("li",[o._v("CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变")]),o._v(" "),e("li",[o._v("可以监听的时间点有一下几个：")])]),o._v(" "),e("h2",{attrs:{id:"_6-runloop处理逻辑"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-runloop处理逻辑"}},[o._v("#")]),o._v(" 6. RunLoop处理逻辑")]),o._v(" "),e("h2",{attrs:{id:"_7-自动释放池与runloop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-自动释放池与runloop"}},[o._v("#")]),o._v(" 7. 自动释放池与RunLoop")]),o._v(" "),e("ul",[e("li",[e("code",[o._v("kCFRunLoopEntry;")]),o._v(" 即将进入loop，此时创建一个自动释放池")]),o._v(" "),e("li",[e("code",[o._v("kCFRunLoopBeforeWaiting;")]),o._v(" 即将进入休眠，此时销毁自动释放池，创建一个新的自动释放池")]),o._v(" "),e("li",[e("code",[o._v("kCFRunLoopExit;")]),o._v("  即将退出loop，此时销毁自动释放池")]),o._v(" "),e("li",[o._v("自动释放池的创建和销毁\n"),e("ul",[e("li",[o._v("第一次创建:当runloop启动的时候")]),o._v(" "),e("li",[o._v("最后一次销毁:当runloop退出的时候")]),o._v(" "),e("li",[o._v("其它创建和销毁:当runloop进入到睡觉状态的时候会把之前的自动释放池销毁,重新创建一个新的")])])])]),o._v(" "),e("h2",{attrs:{id:"_8-视频学习记录"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-视频学习记录"}},[o._v("#")]),o._v(" 8. 视频学习记录")]),o._v(" "),e("ul",[e("li",[o._v("链接：https://www.bilibili.com/video/BV1Bv411z774?from=search&seid=7583525792558693256")])]),o._v(" "),e("h3",{attrs:{id:"为什么点击屏幕会唤醒runloop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么点击屏幕会唤醒runloop"}},[o._v("#")]),o._v(" 为什么点击屏幕会唤醒RunLoop？")]),o._v(" "),e("ul",[e("li",[e("p",[o._v("首先是硬件，把触摸/锁屏/摇晃等事件 通过IOKit.framework，将用户的行为封装成IOHIDEvent，传递给iOS的桌面管理系统SpringBoard，SpringBoard通过跨进程通讯mach port传递给App，App触发Source1回调方法__IOHIDEventSystemClientQueueCallback，通过Source1在触发Source0回调方法_UIApplicationHandleEventQueue，将其包装成UIEvent，最后发送给UIWindow，UIWindow在去分发，最后响应到TouchBegin方法")])]),o._v(" "),e("li",[e("p",[o._v("mach port其实是跨线程通讯，但是跨进程通讯本质上也是基于mach port，例如iOS上的剪切板")])]),o._v(" "),e("li",[e("p",[o._v("通过lldb调试台打断点查看__IOHIDEventSystemClientQueueCallback方法的回调：")])]),o._v(" "),e("li",[e("p",[o._v("bt可以查看当前调用栈")])])]),o._v(" "),e("h3",{attrs:{id:"可以唤醒runloop的事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可以唤醒runloop的事件"}},[o._v("#")]),o._v(" 可以唤醒Runloop的事件")]),o._v(" "),e("ul",[e("li",[e("p",[o._v("timer")])]),o._v(" "),e("li",[e("p",[o._v("source，到底是source0唤醒的还是source1唤醒的")])]),o._v(" "),e("li",[e("p",[o._v("Source0：不能主动触发，先调用CFRunLoopSourceSignal(source)，将这个Source标记为待处理。CFRunLoopWakeUp(runloop)来唤醒Runloop，让其处理这个事件")])]),o._v(" "),e("li",[e("p",[o._v("Source1：基于mach_port，用于通过内核和其他线程相互发送消息，这种Source能主动唤醒RunLoop的线程")])])]),o._v(" "),e("h2",{attrs:{id:"_9-runloop的mode是如何切换的-runloop的mode切换时-上一个mode是需要退出吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-runloop的mode是如何切换的-runloop的mode切换时-上一个mode是需要退出吗"}},[o._v("#")]),o._v(" 9. Runloop的mode是如何切换的？Runloop的mode切换时，上一个mode是需要退出吗？")]),o._v(" "),e("ul",[e("li",[o._v("UITableView滑动时，Runloop会进行切换mode，由kCFRunLoopDefaultMode切换为UITrackingRunLoopMode，根据源码，切换mode实际是调用CFRunLoopRunSpecific 这个函数")]),o._v(" "),e("li",[o._v("Runloop的mode切换时，上一个mode会退出")])])])}),[],!1,null,null,null);r.default=a.exports}}]);