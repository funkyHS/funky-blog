(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{465:function(a,t,_){"use strict";_.r(t);var e=_(45),v=Object(e.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("p"),_("div",{staticClass:"table-of-contents"},[_("ul",[_("li",[_("a",{attrs:{href:"#_1-事务-transaction"}},[a._v("1. 事务（Transaction）")]),_("ul",[_("li",[_("a",{attrs:{href:"#_1-1-什么是事务"}},[a._v("1.1 什么是事务")])]),_("li",[_("a",{attrs:{href:"#_1-2-事务的特性"}},[a._v("1.2 事务的特性")])]),_("li",[_("a",{attrs:{href:"#_1-3-使用事务"}},[a._v("1.3 使用事务")])])])]),_("li",[_("a",{attrs:{href:"#_2-索引"}},[a._v("2. 索引")]),_("ul",[_("li",[_("a",{attrs:{href:"#_2-1-什么是索引"}},[a._v("2.1 什么是索引")])]),_("li",[_("a",{attrs:{href:"#_2-2-创建及删除索引对象"}},[a._v("2.2 创建及删除索引对象")])]),_("li",[_("a",{attrs:{href:"#_2-3-什么时候考虑给字段添加索引"}},[a._v("2.3 什么时候考虑给字段添加索引")])]),_("li",[_("a",{attrs:{href:"#_2-4-索引的实现原理"}},[a._v("2.4 索引的实现原理")])]),_("li",[_("a",{attrs:{href:"#_2-5-索引的分类"}},[a._v("2.5 索引的分类")])])])]),_("li",[_("a",{attrs:{href:"#_3-视图"}},[a._v("3. 视图")])]),_("li",[_("a",{attrs:{href:"#_4-dba命令"}},[a._v("4. DBA命令")]),_("ul",[_("li",[_("a",{attrs:{href:"#_4-1-将数据库当中的数据导出"}},[a._v("4.1 将数据库当中的数据导出")])]),_("li",[_("a",{attrs:{href:"#_4-2-导入数据"}},[a._v("4.2 导入数据")])])])]),_("li",[_("a",{attrs:{href:"#_5-数据库设计三范式"}},[a._v("5. 数据库设计三范式")])]),_("li",[_("a",{attrs:{href:"#参考"}},[a._v("参考")])])])]),_("p"),a._v(" "),_("h2",{attrs:{id:"_1-事务-transaction"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-事务-transaction"}},[a._v("#")]),a._v(" 1. 事务（Transaction）")]),a._v(" "),_("h3",{attrs:{id:"_1-1-什么是事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-什么是事务"}},[a._v("#")]),a._v(" 1.1 什么是事务")]),a._v(" "),_("ul",[_("li",[a._v("一个事务是一个完整的业务逻辑单元，不可再分")]),a._v(" "),_("li",[a._v("比如：银行账户转账，从A账户向B账户转账10000.需要执行两条update语句：\n"),_("ul",[_("li",[a._v("update t_act set balance = balance - 10000 where actno = 'act-001';")]),a._v(" "),_("li",[a._v("update t_act set balance = balance + 10000 where actno = 'act-002';")]),a._v(" "),_("li",[a._v("以上两条DML语句必须同时成功，或者同时失败，不允许出现一条成功，一条失败。要想保证以上的两条DML语句同时成功或者同时失败，那么就需要使用数据库的“事务机制”。")])])]),a._v(" "),_("li",[a._v("和事务相关的语句只有：DML语句。（insert delete update）因为它们这三个语句都是和数据库表当中的“数据”相关的。")]),a._v(" "),_("li",[a._v("事务的存在是为了保证数据的完整性，安全性。")]),a._v(" "),_("li",[a._v("假设所有的业务都能使用1条DML语句搞定，那就不需要事务。")]),a._v(" "),_("li",[a._v("开启事物机制 ---\x3e 执行记录到数据库的操作历史当中，并不会操作文件中的数据，先存储到缓存中 ----\x3e 如果所有的执行都没有问题，再提交事物，将缓存的数据同步到硬盘数据 ----\x3e 如果执行出现问题，直接回滚")])]),a._v(" "),_("h3",{attrs:{id:"_1-2-事务的特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-事务的特性"}},[a._v("#")]),a._v(" 1.2 事务的特性")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("事务包括四大特性：ACID")]),a._v(" "),_("ul",[_("li",[a._v("A：原子性：事务是最小的工作单元，不可再分。")]),a._v(" "),_("li",[a._v("C：一致性：事务必须保证多条DML语句同时成功或者同时失败。")]),a._v(" "),_("li",[a._v("I：隔离性：事务A与事务B之间具有隔离。")]),a._v(" "),_("li",[a._v("D：持久性：持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。")])])]),a._v(" "),_("li",[_("p",[a._v("关于事务之间的隔离性")]),a._v(" "),_("ul",[_("li",[a._v("事务隔离性存在隔离级别，理论上隔离级别包括4个：")]),a._v(" "),_("li",[a._v("第一级别：读未提交（read uncommitted）对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。读未提交存在脏读（Dirty Read）现象：表示读到了脏的数据。")]),a._v(" "),_("li",[a._v("第二级别：读已提交（read committed）对方事务提交之后的数据我方可以读取到。这种隔离级别解决了: 脏读现象没有了。读已提交存在的问题是：不可重复读。")]),a._v(" "),_("li",[a._v("第三级别：可重复读（repeatable read） 这种隔离级别解决了：不可重复读问题。这种隔离级别存在的问题是：读取到的数据是幻象。")]),a._v(" "),_("li",[a._v("第四级别：序列化读/串行化读（serializable）解决了所有问题。效率低。需要事务排队。")])])]),a._v(" "),_("li",[_("p",[a._v("oracle数据库默认的隔离级别是：读已提交。mysql数据库默认的隔离级别是：可重复读。")])])]),a._v(" "),_("h3",{attrs:{id:"_1-3-使用事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-使用事务"}},[a._v("#")]),a._v(" 1.3 使用事务")]),a._v(" "),_("ul",[_("li",[a._v("开启事务：start transaction;")]),a._v(" "),_("li",[a._v("插入数据：insert into t_user(username) values('lisi');")]),a._v(" "),_("li",[a._v("开始回滚：rollback;")]),a._v(" "),_("li",[a._v("提交事务：commit;")]),a._v(" "),_("li",[a._v("设置事务的全局隔离级别：set global transaction isolation level read uncommitted")]),a._v(" "),_("li",[a._v("查看事务的全局隔离级别：select @@global.tx isolation;")])]),a._v(" "),_("hr"),a._v(" "),_("h2",{attrs:{id:"_2-索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-索引"}},[a._v("#")]),a._v(" 2. 索引")]),a._v(" "),_("h3",{attrs:{id:"_2-1-什么是索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-什么是索引"}},[a._v("#")]),a._v(" 2.1 什么是索引")]),a._v(" "),_("ul",[_("li",[a._v("索引就相当于一本书的目录，通过目录可以快速的找到对应的资源。")]),a._v(" "),_("li",[a._v("在数据库方面，查询一张表的时候有两种检索方式：1.全表扫描、2.根据索引检索（效率很高）")]),a._v(" "),_("li",[a._v("索引为什么可以提高检索效率呢：最根本的原理是缩小了扫描的范围。")]),a._v(" "),_("li",[a._v("索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中的对象，也需要数据库不断的维护。是有维护成本的。比如，表中的数据经常被修改。这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。")]),a._v(" "),_("li",[a._v("添加索引是给某一个字段，或者说某些字段添加索引。")]),a._v(" "),_("li",[a._v("select ename,sal from emp where ename = 'SMITH';\n"),_("ul",[_("li",[a._v("当ename字段上没有添加索引的时候，以上sql语句会进行全表扫描，扫描ename字段中所有的值。")]),a._v(" "),_("li",[a._v("当ename字段上添加索引的时候，以上sql语句会根据索引扫描，快速定位。")])])]),a._v(" "),_("li",[a._v("注意：主键和具有unique约束的字段自动会添加索引。根据主键查询效率较高。尽量根据主键检索。")])]),a._v(" "),_("h3",{attrs:{id:"_2-2-创建及删除索引对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-创建及删除索引对象"}},[a._v("#")]),a._v(" 2.2 创建及删除索引对象")]),a._v(" "),_("ul",[_("li",[a._v("创建索引对象：create index 索引名称 on 表名(字段名);")]),a._v(" "),_("li",[a._v("删除索引对象：drop index 索引名称 on 表名;")]),a._v(" "),_("li",[a._v("查看sql语句的执行计划：explain select ename,sal from emp where sal = 5000; ==> type：ALL，rows：14")]),a._v(" "),_("li",[a._v("给薪资sal字段添加索引:  create index emp_sal_index on emp(sal);\n"),_("ul",[_("li",[a._v("再查看sql语句的执行计划：explain select ename,sal from emp where sal = 5000; ==> ref，rows：1")])])]),a._v(" "),_("li",[a._v("索引底层采用的数据结构是：B + Tree")])]),a._v(" "),_("h3",{attrs:{id:"_2-3-什么时候考虑给字段添加索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-什么时候考虑给字段添加索引"}},[a._v("#")]),a._v(" 2.3 什么时候考虑给字段添加索引")]),a._v(" "),_("ul",[_("li",[a._v("数据量庞大。（根据客户的需求，根据线上的环境）")]),a._v(" "),_("li",[a._v("该字段很少的DML操作。（因为字段进行修改操作，索引也需要维护）")]),a._v(" "),_("li",[a._v("该字段经常出现在where子句中。（经常根据哪个字段查询）")])]),a._v(" "),_("h3",{attrs:{id:"_2-4-索引的实现原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-索引的实现原理"}},[a._v("#")]),a._v(" 2.4 索引的实现原理")]),a._v(" "),_("ul",[_("li",[a._v("通过B Tree缩小扫描范围，底层索引进行了排序，分区，索引会携带数据在表中的“物理地址”，最终通过索引检索到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据，效率是最高的。")]),a._v(" "),_("li",[a._v("数据库表中的每一行数据都对应有物理地址与之关联")]),a._v(" "),_("li",[a._v("索引什么时候失效：\n"),_("ul",[_("li",[a._v("select ename from emp where ename like '%A%';")]),a._v(" "),_("li",[a._v("模糊查询的时候，第一个通配符使用的是%，这个时候索引是失效的。")])])])]),a._v(" "),_("h3",{attrs:{id:"_2-5-索引的分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-索引的分类"}},[a._v("#")]),a._v(" 2.5 索引的分类")]),a._v(" "),_("ul",[_("li",[a._v("单一索引：给单个字段添加索引")]),a._v(" "),_("li",[a._v("复合索引: 给多个字段联合起来添加1个索引")]),a._v(" "),_("li",[a._v("主键索引：主键上会自动添加索引")]),a._v(" "),_("li",[a._v("唯一索引：有unique约束的字段上会自动添加索引")])]),a._v(" "),_("hr"),a._v(" "),_("h2",{attrs:{id:"_3-视图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-视图"}},[a._v("#")]),a._v(" 3. 视图")]),a._v(" "),_("ul",[_("li",[a._v("视图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，java程序员只对视图对象进行CRUD。")]),a._v(" "),_("li",[a._v("对视图进行增删改查，会影响到原表数据。")])]),a._v(" "),_("div",{staticClass:"language-sql extra-class"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 创建视图：")]),a._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("create")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("view")]),a._v(" myview "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("as")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("select")]),a._v(" empno"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("ename "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("from")]),a._v(" emp"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 删除视图：")]),a._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("drop")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("view")]),a._v(" myview"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),_("hr"),a._v(" "),_("h2",{attrs:{id:"_4-dba命令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-dba命令"}},[a._v("#")]),a._v(" 4. DBA命令")]),a._v(" "),_("h3",{attrs:{id:"_4-1-将数据库当中的数据导出"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-将数据库当中的数据导出"}},[a._v("#")]),a._v(" 4.1 将数据库当中的数据导出")]),a._v(" "),_("ul",[_("li",[a._v("导出整个库："),_("code",[a._v("mysqldump funkytest>~/funkytest.sql -uroot -p333")])]),a._v(" "),_("li",[a._v("导出指定数据库当中的指定表："),_("code",[a._v("mysqldump funkytest emp>~/funkytest.sql -uroot –p123")])])]),a._v(" "),_("h3",{attrs:{id:"_4-2-导入数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-导入数据"}},[a._v("#")]),a._v(" 4.2 导入数据")]),a._v(" "),_("ul",[_("li",[_("code",[a._v("create database funkytest;")])]),a._v(" "),_("li",[_("code",[a._v("use funkytest;")])]),a._v(" "),_("li",[_("code",[a._v("source ~/funkytest.sql")])])]),a._v(" "),_("hr"),a._v(" "),_("h2",{attrs:{id:"_5-数据库设计三范式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-数据库设计三范式"}},[a._v("#")]),a._v(" 5. 数据库设计三范式")]),a._v(" "),_("ul",[_("li",[a._v("设计范式：设计表的依据。按照这个三范式设计的表不会出现数据冗余")]),a._v(" "),_("li",[a._v("三范式都是哪些\n"),_("ul",[_("li",[a._v("第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。")]),a._v(" "),_("li",[a._v("第二范式：建立在第一范式的基础之上，所有非主键字段完全依赖主键，不能产生部分依赖。（多对多，三张表，关系表两个外键）")]),a._v(" "),_("li",[a._v("第三范式：建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。（一对多，两张表，多的表加外键。）")])])]),a._v(" "),_("li",[a._v("提醒：在实际的开发中，以满足客户的需求为主，有的时候会拿冗余换执行速度。")])]),a._v(" "),_("h2",{attrs:{id:"参考"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[a._v("#")]),a._v(" 参考")]),a._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://www.bilibili.com/video/av57575364",target:"_blank",rel:"noopener noreferrer"}},[a._v("MySQL基础入门-mysql教程-数据库实战"),_("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=v.exports}}]);