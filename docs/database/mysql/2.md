---
title: 【MySql基础】
---

[[TOC]]



## 1. 常见的数据库管理系统
- Oracle 甲骨文公司，全球最大的企业级软件公司（数据库起家，号称世界上最强的数据库系统）
- 在2008年初，Sun Microsystems收购了MySQL AB公司。在2009年，Oracle以74亿美元收购了Sun公司，使MySQL并入Oracle的数据库产品线，同时Java语言由Oracle公司开发与维护
- 2013年，甲骨文已超越 IBM ，成为继 Microsoft 后全球第二大软件公司。
- 曾经IBM公司想收购SUN公司，开发了eclipse开发工具，翻译为日食，语义就是吞并太阳，但是没有成功，后来被Oracle收购了
- IDEA（市场占有60%）提示功能强大，Eclipse（40%）IBM公司推出的
- Oracle 是做数据库起家的，数据库处理速度快，安全机制强大，Oracle 收购了瑞典MySQL AB公司，MySQL是免费的开源的数据库
- 常见的数据库管理系统：Oracle，MySQL，DB2，Sybase， "MS SqlServer" （微软的 支持标准sql的数据库管理系统）
- 一般互联网公司喜欢使用 MySQL，免费，轻量级，安装快，便于搭建集群
- 传统行业喜欢使用Oracle，银行，政府企业，Oracle收费，重量级，安全机制强大



--------------------------------------------------------------------------


## 2. 初识MySQL

### 2.1 下载并安装MySQL
- 下载地址：[https://dev.mysql.com/downloads/mysql/](https://dev.mysql.com/downloads/mysql/)
- 下载安装完成以后，打开Mac “系统偏好设置”，会发现多了一个MySQL图标，点击它，会进入MySQL的设置界面
<!-- ![](https://raw.githubusercontent.com/funkyHS/imgrepo/master/myself/funkyblog/database/mysql/2/1.png =400x300) -->
<br/><img src="https://raw.githubusercontent.com/funkyHS/imgrepo/master/myself/funkyblog/database/mysql/2/1.png" width="500"/>


- 在终端登陆mysql：`mysql -u root -p`,然后输入密码
<br/><img src="https://raw.githubusercontent.com/funkyHS/imgrepo/master/myself/funkyblog/database/mysql/2/2.png" width="500"/>

- mysql默认的端口号是3306


### 2.2 修改mysql密码
- 方法1： 用SET PASSWORD命令 
```shell
# 首先登录MySQL：
mysql -u root -p

# 格式：mysql> set password for 用户名@localhost = password('新密码'); 
mysql> set password for root@localhost = password('123'); 
```

- 方法2：用mysqladmin 
```shell
# 格式：mysqladmin -u用户名 -p旧密码 password 新密码
mysqladmin -uroot -p123456 password 123
```

- 方法3：用UPDATE直接编辑user表 
```shell
# 首先登录MySQL。 
mysql> use mysql;
mysql> update user set password=password('123') where user='root' and host='localhost';
mysql> flush privileges;
```

- 方法4：在忘记root密码的时候，（以windows为例）
```shell
(1) 关闭正在运行的MySQL服务。 
(2) 打开DOS窗口，转到mysql\bin目录。 
(3) 输入`mysqld --skip-grant-tables` 回车。`--skip-grant-tables `的意思是启动MySQL服务的时候跳过权限表认证。 
(4) 再开一个DOS窗口（因为刚才那个DOS窗口已经不能动了），转到mysql\bin目录。 
(5) 输入mysql回车，如果成功，将出现MySQL提示符 >。 
(6) 连接权限数据库： use mysql; 。 
(7) 改密码：`update user set password=password("123") where user="root";`（别忘了最后加分号） 。 
(8) 刷新权限（必须步骤）：`flush privileges;`　。 
(9) 退出 `quit`。 
(10) 注销系统，再进入，使用用户名root和刚才设置的新密码123登录。
```

### 2.3 DB、DBMS、SQL分别是什么，他们之间的关系
- `DB`: DataBase（数据库，数据库实际上在硬盘上以文件的形式存在）
- `DBMS`: DataBase Management System（数据库管理系统，常见的有：MySQL Oracle DB2 Sybase SqlServer...）
- `SQL`: 结构化查询语言，是一门标准通用的语言。标准的sql适合于所有的数据库产品。
    - SQL属于高级语言。
    - SQL语句在执行的时候，实际上内部也会先进行编译，然后再执行sql。（sql语句的编译由DBMS完成。）
- `关系`: DBMS负责执行sql语句，通过执行sql语句来操作DB当中的数据：`DBMS -(执行)-> SQL -(操作)-> DB`


### 2.4 SQL语句分类
- DQL（数据查询语言）: 查询语句，凡是select语句都是DQL。
- DML（数据操作语言）：insert delete update，对表当中的数据进行增删改。
- DDL（数据定义语言）：create drop alter，对表结构的增删改。
- TCL（事务控制语言）：commit提交事务，rollback回滚事务。(TCL中的T是Transaction)
- DCL（数据控制语言）: grant授权、revoke撤销权限等。


--------------------------------------------------------------------------


## 3. 常用的数据库相关命令

```shell
# 查看有哪些数据库
mysql> show databases;

# 创建数据库
mysql> create database funkytest;

# 使用funkytest数据库
mysql> use funkytest;

# 查看当前使用的数据库中有哪些表
mysql> show tables;

# 初始化数据
# funkytest.sql：sql脚本，当一个文件的扩展名是.sql，并且该文件中编写了大量的sql语句，称sql脚本
# 注意：直接使用source命令可以执行sql脚本。sql脚本中的数据量太大的时候，无法打开，使用source命令完成初始化。
mysql> source ~/Desktop/funkytest.sql

# 删除数据库
mysql> drop database funkytest;

# 查看表结构
mysql> desc DEPT;

# 表中的数据
mysql> select * from DEPT;

# 查看当前使用的是哪个数据库
mysql> select database();

# 查看mysql的版本号
mysql> select version();

# `\c`   命令，结束一条语句
# 退出mysql
mysql> exit

# 查看创建表的语句
mysql> show create table emp;

```
- 查看当前使用的数据库中有哪些表
<br/><img src="https://raw.githubusercontent.com/funkyHS/imgrepo/master/myself/funkyblog/database/mysql/2/3.png" width="500"/>

- 退出mysql
<br/><img src="https://raw.githubusercontent.com/funkyHS/imgrepo/master/myself/funkyblog/database/mysql/2/4.png" width="500"/>

- 查看创建表的语句
<br/><img src="https://raw.githubusercontent.com/funkyHS/imgrepo/master/myself/funkyblog/database/mysql/2/5.png" width="500"/>

- 查看`funkytest`存储的表中的数据
<br/><img src="https://raw.githubusercontent.com/funkyHS/imgrepo/master/myself/funkyblog/database/mysql/2/6.png" width="500"/>



---------------------------------------------------------------------------------


## 4 查询语句
### 4.1 简单的查询语句（DQL）
- 语法格式：select 字段名1,字段名2,字段名3,.... from 表名;
- 提示：任何一条sql语句以“;”结尾。sql语句不区分大小写。
- 查询员工的年薪:（字段可以参与数学运算。）`select ename,sal * 12 from emp;`
- 给查询结果的列重命名：`select ename,sal * 12 as yearsal from emp;`
- 别名中有中文：
    - `select ename,sal * 12 as 年薪 from emp;` // 错误
    - `select ename,sal * 12 as '年薪' from emp;`
    - 注意：标准sql语句中要求字符串使用单引号括起来。虽然mysql支持双引号，尽量别用。
- as关键字可以省略：`select empno,ename,sal * 12 yearsal from emp;`
- 查询所有字段：`select * from emp;` // 实际开发中不建议使用*，效率较低。


### 4.2 条件查询
- 语法格式：select  字段,字段... from 表名  where 条件;
- 查询工资等于5000的员工姓名：`select ename from emp where sal = 5000;`
- 查询SMITH的工资：`select sal from emp where ename = 'SMITH';` // 字符串使用单引号括起来。
- 找出工资高于等于3000的员工：`select ename,sal from emp where sal >= 3000;`
- 找出工资不等于3000的：
    - `select ename,sal from emp where sal <> 3000;`
    - `select ename,sal from emp where sal != 3000;`
- 找出工资在1100和3000之间的员工，包括1100和3000
    - `select ename,sal from emp where sal >= 1100 and sal <= 3000;`
    - `select ename,sal from emp where sal between 1100 and 3000;` // between...and...是闭区间 [1100 ~ 3000]
    - `select ename,sal from emp where sal between 3000 and 1100;` // 查询不到任何数据
- between and在使用的时候必须左小右大。between and除了可以使用在数字方面之外，还可以使用在字符串方面。
    - `select ename from emp where ename between 'A' and 'C';`
    - `select ename from emp where ename between 'A' and 'D';` // 用在字符上面是 左闭右开。
- 找出哪些人津贴为NULL：
    - 在数据库当中NULL不是一个值，代表什么也没有，为空。不能用等号衡量。必须使用 `is null`或者`is not null`
    - `select ename,sal,comm from emp where comm is null;`
- 找出哪些人津贴不为NULL：
    - `select ename,sal,comm from emp where comm is not null;`
- 找出哪些人没有津贴：
    - `select ename,sal,comm from emp where comm is null or comm = 0;`
- 找出工作岗位是MANAGER和SALESMAN的员工：
    - `select ename,job from emp where job = 'MANAGER' or job = 'SALESMAN'`
- and和or联合起来用：找出薪资大于1000的并且部门编号是20或30部门的员工
    - `select ename,sal,deptno from emp where sal > 1000 and deptno = 20 or deptno = 30;` // 错误的
    - `select ename,sal,deptno from emp where sal > 1000 and (deptno = 20 or deptno = 30);` // 正确的。
    - 注意：当运算符的优先级不确定的时候加小括号。
- in等同于or：找出工作岗位是MANAGER和SALESMAN的员工
    - `select ename,job from emp where job = 'SALESMAN' or job = 'MANAGER';`
    - `select ename,job from emp where job in('SALESMAN', 'MANAGER');`
    - `select ename,job from emp where sal in(800, 5000);` // in后面的值不是区间，是具体的值。
- 模糊查询like：在模糊查询当中，必须掌握两个特殊的符号，一个是`%`，一个是`_`。`%`代表任意多个字符，`_`代表任意1个字符。
    - 找出名字当中含有O的：`select ename from emp where ename like '%O%';`
    - 找出名字中第二个字母是A的：`select ename from emp where ename like '_A%';`
    - 找出名字中有下划线的：`select name from t_user where name like '%\_%';`
    - 找出名字中最后一个字母是T的：`select ename from emp where ename like '%T';`



### 4.3 排序（升序、降序）
- 按照工资升序，找出员工名和薪资
    - 默认是升序。asc表示升序，desc表示降序。
    - `select ename , sal from emp order by sal;` // 升序
    - `select ename , sal from emp order by sal asc;` // 升序
    - `select ename , sal from emp order by sal desc;` // 降序。
- 按照工资的降序排列，当工资相同的时候再按照名字的升序排列
    - `select ename,sal from emp order by sal desc;`
    - `select ename,sal from emp order by sal desc , ename asc;`
    - 注意：越靠前的字段越能起到主导作用。只有当前面的字段无法完成排序的时候，才会启用后面的字段。
- 找出工作岗位是SALESMAN的员工，并且要求按照薪资的降序排列
    - `select ename,job,sal from emp where job = 'SALESMAN' order by sal desc;`



### 4.4 分组函数（多行处理函数）
- 分组函数一共5个。count 计数、sum 求和、avg 平均值、max 最大值、min 最小值
- 记住：所有的分组函数都是对“某一组”数据进行操作的。
- 找出工资总和：`select sum(sal) from emp;`
- 找出最高工资：`select max(sal) from emp;`
- 找出最低工资：`select min(sal) from emp;`
- 找出平均工资：`select avg(sal) from emp;`
- 找出总人数：
    - `select count(*) from emp;`
    - `select count(ename) from emp;`
- 分组函数自动忽略NULL：
    - `select count(comm) from emp;`
    - `select sum(comm) from emp where comm is not null;` // 不需要额外添加这个过滤条件。sum函数自动忽略NULL。
- 找出工资高于平均工资的员工
    - `select avg(sal) from emp;` // 平均工资
    - `select ename,sal from emp where sal > avg(sal);` // ERROR 1111 (HY000): Invalid use of group function
    - 上面错误原因：SQL语句当中有一个语法规则，分组函数不可直接使用在where子句当中。因为`group by是在where执行之后才会执行的`。
    - 第一步：找出平均工资  `select avg(sal) from emp;`
    - 第二步：找出高于平均工资的员工  `select ename,sal from emp where sal > 2073.214286;`
    - `select ename,sal from emp where sal > (select avg(sal) from emp);`
- count(*)和count(具体的某个字段)，他们有什么区别
    - count(*):不是统计某个字段中数据的个数，而是统计总记录条数。（和某个字段无关）
    - count(comm): 表示统计comm字段中不为NULL的数据总数量。
- 分组函数也能组合起来用：`select count(*),sum(sal),avg(sal),max(sal),min(sal) from emp;`
<br/><img src="https://raw.githubusercontent.com/funkyHS/imgrepo/master/myself/funkyblog/database/mysql/2/7.png" width="500"/>



### 4.5 单行处理函数
- 计算每个员工的年薪
    - `select ename,(sal+comm)*12 as yearsal from emp;`
    - 重点：`所有数据库都是这样规定的，只要有NULL参与的运算结果一定是NULL`。
    - 使用ifnull函数：`select ename,(sal+ifnull(comm,0))*12 as yearsal from emp;`
- ifnull() 空处理函数：ifnull(可能为NULL的数据,被当做什么处理) ，属于单行处理函数。
    - `select ename,ifnull(comm,0) as comm from emp;`
<br/><img src="https://raw.githubusercontent.com/funkyHS/imgrepo/master/myself/funkyblog/database/mysql/2/8.png" width="500"/>



### 4.6 group by 和 having
- `group by` : 按照某个字段或者某些字段进行分组。
- `having` : having是对分组之后的数据进行再次过滤。
- 找出每个工作岗位的最高薪资：
    - `select max(sal),job from emp group by job;`
- 注意：分组函数一般都会和group by联合使用，这也是为什么它被称为分组函数的原因。
- 并且任何一个分组函数（count sum avg max min）都是在group by语句执行结束之后才会执行的。
- select ename,max(sal),job from emp group by job; // 语法错误。
- 记住一个规则：`当一条语句中有group by的话，select后面只能跟分组函数和参与分组的字段。`
- 每个工作岗位的平均薪资: 
    - `select job,avg(sal) from emp group by job;`
- 找出每个部门不同工作岗位的最高薪资: 
    - `select deptno,job,max(sal) from emp group by deptno,job;`
- 找出每个部门的最高薪资，要求显示薪资大于2900的数据。
    - 第一步：找出每个部门的最高薪资：`select max(sal),deptno from emp group by deptno;`
    - 第二步：找出薪资大于2900： `select max(sal),deptno from emp group by deptno having max(sal) > 2900;` // 这种方式效率低。
    - `select max(sal),deptno from emp where sal > 2900 group by deptno;`  // 效率较高，建议能够使用where过滤的尽量使用where。

- 找出每个部门的平均薪资，要求显示薪资大于2000的数据
    - 第一步：找出每个部门的平均薪资：`select deptno,avg(sal) from emp group by deptno;`
    - 第二步：要求显示薪资大于2000的数据：`select deptno,avg(sal) from emp group by deptno having avg(sal) > 2000;`  
    - where后面不能使用分组函数：`select deptno,avg(sal) from emp where avg(sal) > 2000 group by deptno;`    // 错误了。这种情况只能使用having过滤。


### 4.7 查询结果集的去重
- `select distinct job from emp;` // distinct关键字去除重复记录。
- select ename,distinct job from emp; // 错误的。
- 记住：distinct只能出现在所有字段的最前面。
- 联合去重：`select distinct deptno,job from emp;`
- 统计岗位的数量：`select count(distinct job) from emp;`

### 4.8 完整的DQL语句的执行次序
```sql
    select        5
        ..
    from            1    
        ..
    where            2
        ..
    group by        3
        ..
    having        4
        ..
    order by        6
        ..
```



--------------------------------------------------------------------------


## 5. 连接查询

### 5.1 连接查询
- 在实际开发中，大部分的情况下都不是从单表中查询数据，一般都是多张表联合查询取出最终的结果。
- 在实际开发中，一般一个业务都会对应多张表，比如：学生和班级，起码两张表。
 - 表的别名：select e.ename,d.dname from emp e,dept d;
    - 表的别名好处：第一：执行效率高，第二：可读性好。

- 查询每个员工的部门名称，要求显示员工名和部门名
    - SQL92:（太老，不用了）`select e.ename,d.dname from emp e, dept d where e.deptno = d.deptno;`
    - SQL99：（常用的）`select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;`
    - inner可以省略的，带着inner目的是可读性好一些：`select e.ename,d.dname from emp e inner join dept d on e.deptno = d.deptno;`
    - SQL99语法结构更清晰一些：表的连接条件和后来的where条件分离了。
 
- 找出每个员工的工资等级，要求显示员工名、工资、工资等级
    - `select e.ename,e.sal,s.grade from emp e inner join salgrade s on e.sal between s.losal and s.hisal;` // inner可以省略
    
- 找出每个员工的上级领导，要求显示员工名和对应的领导名 
    - `select a.ename as '员工名',b.ename as '领导名'  from  emp a  inner join emp b on a.mgr = b.empno;`
 

### 5.2 外连接
- 什么是外连接，和内连接有什么区别
    - 内连接：假设A和B表进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来，这就是内连接。AB两张表没有主副之分，两张表是平等的。
    - 外连接：假设A和B表进行连接，使用外连接的话，AB两张表中有一张表是主表，一张表是副表，主要查询主表中的数据，捎带着查询副表，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配。
    - 外连接的分类：左外连接（左连接）：表示左边的这张表是主表。右外连接（右连接）：表示右边的这张表是主表。
    - 左连接有右连接的写法，右连接也会有对应的左连接的写法。

- 找出每个员工的上级领导？（所有员工必须全部查询出来。）
    - 内连接：`select a.ename as '员工名',b.ename as '领导名' from emp a inner join emp b on a.mgr = b.empno;`
    - 外连接：（左外连接/左连接，表示左边是主表）：`select a.ename '员工', b.ename '领导' from emp a left join emp b on a.mgr = b.empno;`
    - 外连接：（右外连接/右连接，表示右边是主表）：`select a.ename '员工', b.ename '领导' from emp b right join emp a on a.mgr = b.empno;`
    - 外连接最重要的特点是：主表的数据无条件的全部查询出来。副表没有与之匹配的，就以NULL匹配
- 找出哪个部门没有员工：
    - `select d.* from emp e right join dept d on e.deptno = d.deptno where e.empno is null;`


### 5.3 三张表连接查询
- 找出每一个员工的部门名称以及工资等级：
    - `select e.ename,d.dname,s.grade from emp e join dept d on e.deptno = d.deptno join salgrade s on e.sal between s.losal and s.hisal;`

- 找出每一个员工的部门名称、工资等级、以及上级领导
    - `select e.ename '员工',d.dname,s.grade,e1.ename '领导' from emp e join dept d on e.deptno = d.deptno join salgrade s on e.sal between s.losal and s.hisal left join emp e1 on e.mgr = e1.empno;`


--------------------------------------------------------------------------

## 6. 子查询
- select语句当中嵌套select语句，被嵌套的select语句是子查询。

### 6.1 where子句中使用子查询
- 找出高于平均薪资的员工信息
    - `select * from emp where sal > avg(sal);` //错误的写法，where后面不能直接使用分组函数。
    - `select * from emp where sal > (select avg(sal) from emp);`

### 6.2 from后面嵌套子查询
- 找出每个部门平均薪水的等级
    - 第一步：找出每个部门平均薪水（按照部门编号分组，求sal的平均值）：select deptno,avg(sal) as avgsal from emp group by deptno;
    - 第二步：将以上的查询结果当做临时表t，让t表和salgrade s表连接，条件是：t.avgsal between s.losal and s.hisal
    - `select t.*,s.grade from (select deptno,avg(sal) as avgsal from emp group by deptno) t join salgrade s on t.avgsal between s.losal and s.hisal;`


### 6.3 在select后面嵌套子查询
- 找出每个员工所在的部门名称，要求显示员工名和部门名
    - `select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;`
    - `select e.ename,(select d.dname from dept d where e.deptno = d.deptno) as dname from emp e;`



--------------------------------------------------------------------------

## 7. union (可以将查询结果集相加)
- 找出工作岗位是SALESMAN和MANAGER的员工
    - 第一种：`select ename,job from emp where job = 'MANAGER' or job = 'SALESMAN';`
    - 第二种：`select ename,job from emp where job in('MANAGER','SALESMAN');`
    - 第三种：`select ename,job from emp where job = 'MANAGER' `union` select ename,job from emp where job = 'SALESMAN';`
- union可以将两张不相干的表中的数据拼接在一起显示
    - `select ename from emp union select dname from dept;`
- select ename,sal from emp union select dname from dept;
    - ERROR 1222 (21000): The used SELECT statements have a different number of columns


--------------------------------------------------------------------------

## 8. limit
- limit是mysql特有的，其他数据库中没有，不通用。（Oracle中有一个相同的机制，叫做rownum）
- 语法机制：`limit startIndex, length`   startIndex表示起始位置，从0开始，0表示第一条数据。length表示取几个
- 取出工资前5名的员工
    - `select ename,sal from emp order by sal desc limit 0, 5;`
    - `select ename,sal from emp order by sal desc limit 5;`
- limit是sql语句最后执行的一个环节：
```sql
    select        5
        ...
    from            1
        ...        
    where            2
        ...    
    group by        3
        ...
    having        4
        ...
    order by        6
        ...
    limit            7
        ...;
```
- 找出工资排名在第4到第9名的员工:  `select ename,sal from emp order by sal desc limit 3,6;`
- 通用的标准分页sql：
    - 每页显示pageSize条记录，第pageNo页：`(pageNo - 1) * pageSize, pageSize`



--------------------------------------------------------------------------

## 9 增删改查

### 9.1 创建表
- 建表语句的语法格式
```sql
create table 表名(
            字段名1 数据类型,
            字段名2 数据类型,
            字段名3 数据类型,
            ....
);
```
- MySQL当中字段常见的数据类型
    - int        整数型(java中的int)
    - bigint    长整型(java中的long)
    - float        浮点型(java中的float double)
    - char        定长字符串(String)
    - varchar    可变长字符串(StringBuffer/StringBuilder)
    - date        日期类型 （对应Java中的java.sql.Date类型）
    - BLOB        二进制大对象（存储图片、视频等流媒体信息） Binary Large OBject （对应java中的Object）
    - CLOB        字符大对象（存储较大文本，比如，可以存储4G的字符串。） Character Large OBject（对应java中的Object）

- char和varchar怎么选择
    - 在实际的开发中，当某个字段中的数据长度不发生改变的时候，是定长的，例如：性别、生日等都是采用char。
    - 当一个字段的数据长度不确定，例如：简介、姓名等都是采用varchar。

- 创建学生表
```sql
        create table t_student(
            no bigint,
            name varchar(255),
            sex char(1),
            classno varchar(255),
            birth char(10)
        );
```


### 9.2 insert语句插入数据
- 语法格式：insert into 表名(字段名1,字段名2,字段名3,....) values(值1,值2,值3,....)
- 要求：字段的数量和值的数量相同，并且数据类型要对应相同。
- insert into t_student(no,name,sex,classno,birth) values(1,'zhangsan','1','gaosan1ban', '1950-10-12');
- insert into t_student(name,sex,classno,birth,no) values('lisi','1','gaosan1ban', '1950-10-12',2);
- insert into t_student(name) values('wangwu'); // 除name字段之外，剩下的所有字段自动插入NULL。
- insert into t_student(no) values(3);
- drop table if exists t_student; // 当这个表存在的话删除。
- 指定默认值：
```sql
    create table t_student(
        no bigint,
        name varchar(255),
        sex char(1) default 1,
        classno varchar(255),
        birth char(10)
    );
```
- 需要注意的地方：
    - 当一条insert语句执行成功之后，表格当中必然会多一行记录。
    - 即使多的这一行记录当中某些字段是NULL，后期也没有办法在执行
    - insert语句插入数据了，只能使用update进行更新。

- 字段可以省略不写，但是后面的value对数量和顺序都有要求。
    - insert into t_student values(1,'jack','0','gaosan2ban','1986-10-23');
- 一次插入多行数据
    - insert into t_student (no,name,sex,classno,birth) values (3,'rose','1','gaosi2ban','1952-12-14'),(4,'laotie','1','gaosi2ban','1955-12-14');

- 表的复制：create table 表名 as select语句;（将查询结果当做表创建出来。）
- 将查询结果插入到一张表中：insert into dept1 select * from dept;



### 9.3 修改数据：update
- 语法格式：update 表名 set 字段名1=值1,字段名2=值2... where 条件; （没有条件整张表数据全部更新。）
- 将部门10的LOC修改为SHANGHAI，将部门名称修改为RENSHIBU
    - update dept1 set loc = 'SHANGHAI', dname = 'RENSHIBU' where deptno = 10;
- 更新所有记录：update dept1 set loc = 'x', dname = 'y';



### 9.4 删除数据
- 语法格式：delete from 表名 where 条件; （没有条件全部删除。）
- 删除10部门数据：delete from dept1 where deptno = 10;
- 删除所有记录：delete from dept1;
- 怎么删除大表中的数据：truncate table 表名; // 表被截断，不可回滚。永久丢失。
- 删除表：
    - drop table 表名; // 这个通用。
    - drop table if exists 表名; // oracle不支持这种写法。

- 增删改查有一个术语：CRUD操作
    - Create（增） Retrieve（检索） Update（修改） Delete（删除）


----------------------------------------------------------------------------------

## 10 约束（Constraint）

### 10.1 什么是约束？常见的约束有哪些呢？
- 在创建表的时候，可以给表的字段添加相应的约束，添加约束的目的是为了保证表中数据的
- 合法性、有效性、完整性。
- 常见的约束有哪些呢？
    - 非空约束(not null)：约束的字段不能为NULL
    - 唯一约束(unique)：约束的字段不能重复
    - 主键约束(primary key)：约束的字段既不能为NULL，也不能重复（简称PK）
    - 外键约束(foreign key)：...（简称FK）
    - 检查约束(check)：注意Oracle数据库有check约束，但是mysql没有，目前mysql不支持该约束。

### 10.2 非空约束 not null
- drop table if exists t_user;
- create table t_user( id int, username varchar(255) not null, password varchar(255) );
- insert into t_user(id,password) values(1,'123');
    - ERROR 1364 (HY000): Field 'username' doesn't have a default value
- insert into t_user(id,username,password) values(1,'lisi','123');


### 10.3 唯一性约束（unique）
- 唯一约束修饰的字段具有唯一性，不能重复。但可以为NULL。
- 给某一列添加unique
```sql
        drop table if exists t_user;
        create table t_user(
            id int,
            username varchar(255) unique  // 列级约束
        );
        insert into t_user values(1,'zhangsan');
        insert into t_user values(2,'zhangsan');
        ERROR 1062 (23000): Duplicate entry 'zhangsan' for key 'username'

        insert into t_user(id) values(2);
        insert into t_user(id) values(3);
        insert into t_user(id) values(4);
```
- 给两个列或者多个列添加unique
```sql
        drop table if exists t_user;
        create table t_user(
            id int, 
            usercode varchar(255),
            username varchar(255),
            unique(usercode,username) // 多个字段联合起来添加1个约束unique 【表级约束】
        );

        insert into t_user values(1,'111','zs');
        insert into t_user values(2,'111','ls');
        insert into t_user values(3,'222','zs');
        select * from t_user;
        insert into t_user values(4,'111','zs');
        // ERROR 1062 (23000): Duplicate entry '111-zs' for key 'usercode'


        drop table if exists t_user;
        create table t_user(
            id int, 
            usercode varchar(255) unique,
            username varchar(255) unique
        );
        insert into t_user values(1,'111','zs');
        insert into t_user values(2,'111','ls');
        // ERROR 1062 (23000): Duplicate entry '111' for key 'usercode'
```


### 10.4 主键约束
- 给一张表添加主键约束
```sql
        drop table if exists t_user;
        create table t_user(
            id int primary key,  // 列级约束
            username varchar(255),
            email varchar(255)
        );
        insert into t_user(id,username,email) values(1,'zs','zs@123.com');
        insert into t_user(id,username,email) values(2,'ls','ls@123.com');
        insert into t_user(id,username,email) values(3,'ww','ww@123.com');
        select * from t_user;


        insert into t_user(id,username,email) values(1,'jack','jack@123.com');
        // ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY'

        insert into t_user(username,email) values('jack','jack@123.com');
        // ERROR 1364 (HY000): Field 'id' doesn't have a default value
```
- 主键的特点：不能为NULL，也不能重复。一张表的主键约束只能有1个!!
- 主键相关的术语
    - 主键约束 : primary key
    - 主键字段 : id字段添加primary key之后，id叫做主键字段
    - 主键值 : id字段中的每一个值都是主键值。
- 主键有什么作用:
    - 表的设计三范式中有要求，第一范式就要求任何一张表都应该有主键。
    - 主键的作用：主键值是这行记录在这张表当中的唯一标识。（就像一个人的身份证号码一样。）

- 使用表级约束方式定义主键
```sql
        drop table if exists t_user;
        create table t_user(
            id int,
            username varchar(255),
            primary key(id)
        );
        insert into t_user(id,username) values(1,'zs');
        insert into t_user(id,username) values(2,'ls');
        insert into t_user(id,username) values(3,'ws');
        insert into t_user(id,username) values(4,'cs');
        select * from t_user;

        insert into t_user(id,username) values(4,'cx');
        // ERROR 1062 (23000): Duplicate entry '4' for key 'PRIMARY'
```
- mysql提供主键值自增：（非常重要。）
```sql
        drop table if exists t_user;
        create table t_user(
            id int primary key auto_increment, // id字段自动维护一个自增的数字，从1开始，以1递增。
            username varchar(255)
        );
        insert into t_user(username) values('a');
        insert into t_user(username) values('b');
        insert into t_user(username) values('c');
        insert into t_user(username) values('d');
        insert into t_user(username) values('e');
        insert into t_user(username) values('f');
        select * from t_user;
```
- 提示:Oracle当中也提供了一个自增机制，叫做：序列（sequence）对象。



### 10.5 外键约束
- 外键约束: foreign key
- 外键字段：添加有外键约束的字段
- 外键值：外键字段中的每一个值。
- t_student中的classno字段引用t_class表中的cno字段，此时t_student表叫做子表。t_class表叫做父表。
```sql
        drop table if exists t_student;
        drop table if exists t_class;

        create table t_class(
            cno int,
            cname varchar(255),
            primary key(cno)
        );

        create table t_student(
            sno int,
            sname varchar(255),
            classno int,
            primary key(sno),
            foreign key(classno) references t_class(cno)
        );

        insert into t_class values(101,'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx');
        insert into t_class values(102,'yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy');

        insert into t_student values(1,'zs1',101);
        insert into t_student values(2,'zs2',101);
        insert into t_student values(3,'zs3',102);
        insert into t_student values(4,'zs4',102);
        insert into t_student values(5,'zs5',102);
        insert into t_student values(6,'zs6',102);
        select * from t_class;
        select * from t_student;

        insert into t_student values(7,'lisi',103);
        // ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`bjpowernode`.INT `t_student_ibfk_1` FOREIGN KEY (`classno`) REFERENCES `t_class` (`cno`))
```
- 外键可以为NULL。
- 外键字段引用其他表的某个字段的时候，被引用的字段必须是主键吗
    - 注意：被引用的字段不一定是主键，但至少具有unique约束。
        



-----------------------------------------------------------------------------------


## 11 存储引擎

### 11.1 完整的建表语句
```sql
    CREATE TABLE `t_x` (
          `id` int(11) DEFAULT NULL
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```
- 注意：在MySQL当中，凡是标识符是可以使用飘号括起来的。最好别用，不通用。
- 建表的时候可以指定存储引擎，也可以指定字符集。
- mysql默认使用的存储引擎是InnoDB方式。默认采用的字符集是UTF8

### 11.2 存储引擎
- 存储引擎这个名字只有在mysql中存在。（Oracle中有对应的机制，但是不叫做存储引擎。Oracle中没有特殊的名字，就是“表的存储方式”）
- mysql支持很多存储引擎，每一个存储引擎都对应了一种不同的存储方式。
- 每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎。

### 11.3 查看当前mysql支持的存储引擎
- show engines \G
```sql
mysql> show engines \G
*************************** 1. row ***************************
      Engine: ARCHIVE
     Support: YES
     Comment: Archive storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 2. row ***************************
      Engine: BLACKHOLE
     Support: YES
     Comment: /dev/null storage engine (anything you write to it disappears)
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 3. row ***************************
      Engine: MRG_MYISAM
     Support: YES
     Comment: Collection of identical MyISAM tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 4. row ***************************
      Engine: FEDERATED
     Support: NO
     Comment: Federated MySQL storage engine
Transactions: NULL
          XA: NULL
  Savepoints: NULL
*************************** 5. row ***************************
      Engine: MyISAM
     Support: YES
     Comment: MyISAM storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 6. row ***************************
      Engine: PERFORMANCE_SCHEMA
     Support: YES
     Comment: Performance Schema
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 7. row ***************************
      Engine: InnoDB
     Support: DEFAULT
     Comment: Supports transactions, row-level locking, and foreign keys
Transactions: YES
          XA: YES
  Savepoints: YES
*************************** 8. row ***************************
      Engine: MEMORY
     Support: YES
     Comment: Hash based, stored in memory, useful for temporary tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 9. row ***************************
      Engine: CSV
     Support: YES
     Comment: CSV storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
9 rows in set (0.00 sec)
```

### 11.4 常见的存储引擎
- Engine: MyISAM
    - MyISAM这种存储引擎不支持事务。
    - MyISAM是mysql最常用的存储引擎，但是这种引擎不是默认的。
    - MyISAM采用三个文件组织一张表：
        - xxx.frm（存储格式的文件）
        - xxx.MYD（存储表中数据的文件）
        - xxx.MYI（存储表中索引的文件）
    - 优点：可被压缩，节省存储空间。并且可以转换为只读表，提高检索效率。
    - 缺点：不支持事务。

- Engine: InnoDB
    - 优点：支持事务、行级锁、外键等。这种存储引擎数据的安全得到保障。  
    - 表的结构存储在xxx.frm文件中
    - 数据存储在tablespace这样的表空间中（逻辑概念），无法被压缩，无法转换成只读。
    -  这种InnoDB存储引擎在MySQL数据库崩溃之后提供自动恢复机制。
    - InnoDB支持级联删除和级联更新。  


- Engine: MEMORY（以前叫做HEPA引擎）
    - 缺点：不支持事务。数据容易丢失。因为所有数据和索引都是存储在内存当中的。不能包含TEXT或BLOB字段
    - 优点：查询速度最快。


-----------------------------------------------------------------------------------
## 12 事物（Transaction）

### 12.1 什么是事务
- 一个事务是一个完整的业务逻辑单元，不可再分
- 比如：银行账户转账，从A账户向B账户转账10000.需要执行两条update语句：
    - update t_act set balance = balance - 10000 where actno = 'act-001';
    - update t_act set balance = balance + 10000 where actno = 'act-002';
    - 以上两条DML语句必须同时成功，或者同时失败，不允许出现一条成功，一条失败。要想保证以上的两条DML语句同时成功或者同时失败，那么就需要使用数据库的“事务机制”。
- 和事务相关的语句只有：DML语句。（insert delete update）因为它们这三个语句都是和数据库表当中的“数据”相关的。
- 事务的存在是为了保证数据的完整性，安全性。
- 假设所有的业务都能使用1条DML语句搞定，那就不需要事务。
- 开启事物机制 ---> 执行记录到数据库的操作历史当中，并不会操作文件中的数据，先存储到缓存中 ----> 如果所有的执行都没有问题，再提交事物，将缓存的数据同步到硬盘数据 ----> 如果执行出现问题，直接回滚 

### 12.2 事务的特性
- 事务包括四大特性：ACID
    - A：原子性：事务是最小的工作单元，不可再分。
    - C：一致性：事务必须保证多条DML语句同时成功或者同时失败。
    - I：隔离性：事务A与事务B之间具有隔离。
    - D：持久性：持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。

- 关于事务之间的隔离性
    - 事务隔离性存在隔离级别，理论上隔离级别包括4个：
    - 第一级别：读未提交（read uncommitted）对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。读未提交存在脏读（Dirty Read）现象：表示读到了脏的数据。
    - 第二级别：读已提交（read committed）对方事务提交之后的数据我方可以读取到。这种隔离级别解决了: 脏读现象没有了。读已提交存在的问题是：不可重复读。
    - 第三级别：可重复读（repeatable read） 这种隔离级别解决了：不可重复读问题。这种隔离级别存在的问题是：读取到的数据是幻象。
    - 第四级别：序列化读/串行化读（serializable）解决了所有问题。效率低。需要事务排队。
- oracle数据库默认的隔离级别是：读已提交。mysql数据库默认的隔离级别是：可重复读。

### 12.3 使用事物
- 开启事物：start transaction;
- 插入数据：insert into t_user(username) values('lisi');
- 开始回滚：rollback;
- 提交事物：commit;
- 设置事物的全局隔离级别：set global transaction isolation level read uncommitted
- 查看事物的全局隔离级别：select @@global.tx isolation;



-----------------------------------------------------------------------------------

## 13 索引

### 13.1 什么是索引
- 索引就相当于一本书的目录，通过目录可以快速的找到对应的资源。
- 在数据库方面，查询一张表的时候有两种检索方式：1.全表扫描、2.根据索引检索（效率很高）
- 索引为什么可以提高检索效率呢：最根本的原理是缩小了扫描的范围。
- 索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中的对象，也需要数据库不断的维护。是有维护成本的。比如，表中的数据经常被修改。这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。
- 添加索引是给某一个字段，或者说某些字段添加索引。
- select ename,sal from emp where ename = 'SMITH';
    - 当ename字段上没有添加索引的时候，以上sql语句会进行全表扫描，扫描ename字段中所有的值。
    - 当ename字段上添加索引的时候，以上sql语句会根据索引扫描，快速定位。
- 注意：主键和具有unique约束的字段自动会添加索引。根据主键查询效率较高。尽量根据主键检索。

### 13.2 创建及删除索引对象
- 创建索引对象：create index 索引名称 on 表名(字段名);
- 删除索引对象：drop index 索引名称 on 表名;
- 查看sql语句的执行计划：explain select ename,sal from emp where sal = 5000; ==> type：ALL，rows：14
- 给薪资sal字段添加索引:  create index emp_sal_index on emp(sal);
    - 再查看sql语句的执行计划：explain select ename,sal from emp where sal = 5000; ==> ref，rows：1
- 索引底层采用的数据结构是：B + Tree


### 13.3 什么时候考虑给字段添加索引
- 数据量庞大。（根据客户的需求，根据线上的环境）
- 该字段很少的DML操作。（因为字段进行修改操作，索引也需要维护）
- 该字段经常出现在where子句中。（经常根据哪个字段查询）

### 13.4 索引的实现原理
- 通过B Tree缩小扫描范围，底层索引进行了排序，分区，索引会携带数据在表中的“物理地址”，最终通过索引检索到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据，效率是最高的。
- 数据库表中的每一行数据都对应有物理地址与之关联

- 索引什么时候失效：
    - select ename from emp where ename like '%A%';
    - 模糊查询的时候，第一个通配符使用的是%，这个时候索引是失效的。


### 13.5 索引的分类
- 单一索引：给单个字段添加索引
- 复合索引: 给多个字段联合起来添加1个索引
- 主键索引：主键上会自动添加索引
- 唯一索引：有unique约束的字段上会自动添加索引



--------------------------------------------------------------------------------

## 14 视图
- 视图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，java程序员只对视图对象进行CRUD。
- 对视图进行增删改查，会影响到原表数据。
- 创建视图：create view myview as select empno,ename from emp;
- 删除视图：drop view myview;




--------------------------------------------------------------------------------

## 15 DBA命令
- 将数据库当中的数据导出
    - 导出整个库：mysqldump funkytest>D:\funkytest.sql -uroot -p333
    - 导出指定数据库当中的指定表：mysqldump funkytest emp>D:\funkytest.sql -uroot –p123

- 导入数据
    - create database funkytest;
    - use funkytest;
    - source D:\funkytest.sql

--------------------------------------------------------------------------------

## 16 数据库设计三范式
- 设计范式：设计表的依据。按照这个三范式设计的表不会出现数据冗余
- 三范式都是哪些
    - 第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。
    - 第二范式：建立在第一范式的基础之上，所有非主键字段完全依赖主键，不能产生部分依赖。（多对多，三张表，关系表两个外键）
    - 第三范式：建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。（一对多，两张表，多的表加外键。）
- 提醒：在实际的开发中，以满足客户的需求为主，有的时候会拿冗余换执行速度。




## 参考
- [视频学习链接](https://www.bilibili.com/video/av57575364)