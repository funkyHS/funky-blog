---
title: 【4.常量，指针，类型别名】
---

[[TOC]]


## 1. 常量
- Go语言中的常量使用关键字` const `定义，用于存储不会改变的数据，常量是在编译时被创建的，即使定义在函数内部也是如此，并且只能是`布尔型`、`数字型`（整数型、浮点型和复数）和`字符串型`。
- 由于编译时的限制，定义常量的表达式必须为能被编译器求值的常量表达式
~~~go
// 声明格式： const name [type] = value

// type可以省略
const pi = 3.14159

// 和变量声明一样，可以批量声明多个常量
const (
    e  = 2.7182818
    pi = 3.1415926
)

// 如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式，对应的常量类型也是一样的。例如：
const (
    a = 1
    b
    c = 2
    d
)
fmt.Println(a, b, c, d) // "1 1 2 2"


// iota 常量生成器：常量声明可以使用 iota 常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式
// 在一个 const 声明语句中，在第一个声明的常量所在的行，iota 将会被置为 0，然后在每一个有常量声明的行加1
// 比如，定义星期日到星期六，从0-6
const (
    Sunday = iota //0
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday  //6
)
~~~

- 所有常量的运算都可以在编译期完成，这样不仅可以减少运行时的工作，也方便其他代码的编译优化，当操作数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引越界、任何导致无效浮点数的操作等。
- 常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：len、cap、real、imag、complex 和 unsafe.Sizeof。





## 2. 指针
指针（pointer）在Go语言中可以被拆分为两个核心概念
- 类型指针，允许对这个指针类型的数据进行修改，传递数据可以直接使用指针，而无须拷贝数据，类型指针不能进行偏移和运算。
- 切片，由指向起始元素的原始指针、元素数量和容量组成。

受益于这样的约束和拆分，Go语言的指针类型变量即拥有指针高效访问的特点，又不会发生指针偏移，从而避免了非法修改关键性数据的问题。
同时，`垃圾回收`也比较容易对不会发生偏移的指针进行检索和回收。
切片比原始指针具备更强大的特性，而且更为安全。切片在发生越界时，运行时会报出宕机，并打出堆栈，而原始指针只会崩溃。


### 理解指针
```go
var a int = 10

// 在内存中开辟了一片空间，空间内存放着数值10，这片空间在整个内存当中，有一个唯一的地址，用来进行标识，指向这个地址的变量就称为指针
// 内存比作酒店，每个房间就是一块内存，上述代码表示为：定了一间房间a，让10住进了房间，房间有一个门牌号px，这个px就是房间的地址，房卡可以理解为就是指针，指向这个地址。
```

- 一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在 32 和 64 位机器上分别占用 4 或 8 个字节，占用字节的大小与所指向的值的大小无关。
- 当一个指针被定义后`没有分配到任何变量`时，它的默认值为 `nil`。
- 每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。
- Go语言中使用在变量名前面添加`&`操作符（前缀）来获取变量的内存地址（取地址操作），格式如下：
```go
//其中 v 代表被取地址的变量，变量 v 的地址使用变量 ptr 进行接收，ptr 的类型为*T，称做 T 的指针类型，*代表指针。
ptr := &v    // v 的类型为 T


func main() {
	// 指针与变量
	var room int = 10 // room房间 里面放的 变量10
	var ptr = &room   // 门牌号px  指针 0xc0000ba008

	fmt.Printf("%p \n", &room) // 变量的内存地址 0xc0000ba008

	fmt.Printf("%T, %p \n", ptr, ptr) // *int, 0xc0000ba008

	fmt.Println("指针地址", ptr)      // 指针地址 0xc0000ba008
	fmt.Println("指针地址代表的值", *ptr) // 指针地址代表的值 10
}
```
取地址操作符`&`和取值操作符`*`是一对互补操作符，`&`取出地址，`*`根据地址取出地址指向的值
变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：
- 对变量进行取地址操作使用`&`操作符，可以获得这个变量的指针变量。
- 指针变量的值是指针地址。
- 对指针变量进行取值操作使用`*`操作符，可以获得指针变量指向的原变量的值。



### 使用指针修改值
~~~go
package main

func main(){
    // 利用指针修改值
	var num = 10
	modifyFromPoint(num)
	fmt.Println("未使用指针，方法外",num)

	var num2 = 22
	newModifyFromPoint(&num2)  // 传入指针
	fmt.Println("使用指针 方法外",num2)
}
// 未使用指针
func modifyFromPoint(num int)  {
	num = 10000
	fmt.Println("未使用指针，方法内:",num)
}
// 使用指针
func newModifyFromPoint(ptr *int)  {
	*ptr = 1000   // 修改指针地址指向的值
	fmt.Println("使用指针，方法内:",*ptr)
}
~~~


### 创建指针的另一种方法
~~~go
// new(类型)
str := new(string)
*str = "Go语言教程"
fmt.Println(*str)
~~~





## 3. 类型别名
- 类型别名格式：`type TypeAlias = Type`
- 类型定义：`type Name Type`

```go
// 系统的定义
type byte = uint8
type rune = int32
```

- 类型定义与类型别名区别：类型别名只会在代码中存在，编译完成时，不会有“别名”的类型
~~~go
// 将NewInt定义为int类型（类型定义）
type NewInt int
// 将int取一个别名叫IntAlias（类型别名）
type IntAlias = int

func main() {
    // 将a声明为NewInt类型
    var a NewInt
    // 查看a的类型名
    fmt.Printf("a type: %T\n", a) // 打印：main.NewInt

    // 将a2声明为IntAlias类型
    var a2 IntAlias
    // 查看a2的类型名，IntAlias类型只会在代码中存在，编译完成时，不会有IntAlias类型。
    fmt.Printf("a2 type: %T\n", a2) // 打印：int
}
~~~


## 参考
- [Go基础教程](https://www.bilibili.com/video/BV1SS4y1T7kJ)