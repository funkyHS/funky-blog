---
title: 【5. 事务，索引】
---


[[TOC]]



## 1. 事务（Transaction）

### 1.1 什么是事务
- 一个事务是一个完整的业务逻辑单元，不可再分
- 比如：银行账户转账，从A账户向B账户转账10000.需要执行两条update语句：
    - update t_act set balance = balance - 10000 where actno = 'act-001';
    - update t_act set balance = balance + 10000 where actno = 'act-002';
    - 以上两条DML语句必须同时成功，或者同时失败，不允许出现一条成功，一条失败。要想保证以上的两条DML语句同时成功或者同时失败，那么就需要使用数据库的“事务机制”。
- 和事务相关的语句只有：DML语句。（insert delete update）因为它们这三个语句都是和数据库表当中的“数据”相关的。
- 事务的存在是为了保证数据的完整性，安全性。
- 假设所有的业务都能使用1条DML语句搞定，那就不需要事务。
- 开启事物机制 ---> 执行记录到数据库的操作历史当中，并不会操作文件中的数据，先存储到缓存中 ----> 如果所有的执行都没有问题，再提交事物，将缓存的数据同步到硬盘数据 ----> 如果执行出现问题，直接回滚 

### 1.2 事务的特性
- 事务包括四大特性：ACID
    - A：原子性：事务是最小的工作单元，不可再分。
    - C：一致性：事务必须保证多条DML语句同时成功或者同时失败。
    - I：隔离性：事务A与事务B之间具有隔离。
    - D：持久性：持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。

- 关于事务之间的隔离性
    - 事务隔离性存在隔离级别，理论上隔离级别包括4个：
    - 第一级别：读未提交（read uncommitted）对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。读未提交存在脏读（Dirty Read）现象：表示读到了脏的数据。
    - 第二级别：读已提交（read committed）对方事务提交之后的数据我方可以读取到。这种隔离级别解决了: 脏读现象没有了。读已提交存在的问题是：不可重复读。
    - 第三级别：可重复读（repeatable read） 这种隔离级别解决了：不可重复读问题。这种隔离级别存在的问题是：读取到的数据是幻象。
    - 第四级别：序列化读/串行化读（serializable）解决了所有问题。效率低。需要事务排队。
- oracle数据库默认的隔离级别是：读已提交。mysql数据库默认的隔离级别是：可重复读。

### 1.3 使用事务
- 开启事务：start transaction;
- 插入数据：insert into t_user(username) values('lisi');
- 开始回滚：rollback;
- 提交事务：commit;
- 设置事务的全局隔离级别：set global transaction isolation level read uncommitted
- 查看事务的全局隔离级别：select @@global.tx isolation;



-----------------------------------------------------------------------------------


## 2. 索引

### 2.1 什么是索引
- 索引就相当于一本书的目录，通过目录可以快速的找到对应的资源。
- 在数据库方面，查询一张表的时候有两种检索方式：1.全表扫描、2.根据索引检索（效率很高）
- 索引为什么可以提高检索效率呢：最根本的原理是缩小了扫描的范围。
- 索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中的对象，也需要数据库不断的维护。是有维护成本的。比如，表中的数据经常被修改。这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。
- 添加索引是给某一个字段，或者说某些字段添加索引。
- select ename,sal from emp where ename = 'SMITH';
    - 当ename字段上没有添加索引的时候，以上sql语句会进行全表扫描，扫描ename字段中所有的值。
    - 当ename字段上添加索引的时候，以上sql语句会根据索引扫描，快速定位。
- 注意：主键和具有unique约束的字段自动会添加索引。根据主键查询效率较高。尽量根据主键检索。


### 2.2 创建及删除索引对象
- 创建索引对象：create index 索引名称 on 表名(字段名);
- 删除索引对象：drop index 索引名称 on 表名;
- 查看sql语句的执行计划：explain select ename,sal from emp where sal = 5000; ==> type：ALL，rows：14
- 给薪资sal字段添加索引:  create index emp_sal_index on emp(sal);
    - 再查看sql语句的执行计划：explain select ename,sal from emp where sal = 5000; ==> ref，rows：1
- 索引底层采用的数据结构是：B + Tree


### 2.3 什么时候考虑给字段添加索引
- 数据量庞大。（根据客户的需求，根据线上的环境）
- 该字段很少的DML操作。（因为字段进行修改操作，索引也需要维护）
- 该字段经常出现在where子句中。（经常根据哪个字段查询）

### 2.4 索引的实现原理
- 通过B Tree缩小扫描范围，底层索引进行了排序，分区，索引会携带数据在表中的“物理地址”，最终通过索引检索到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据，效率是最高的。
- 数据库表中的每一行数据都对应有物理地址与之关联
- 索引什么时候失效：
    - select ename from emp where ename like '%A%';
    - 模糊查询的时候，第一个通配符使用的是%，这个时候索引是失效的。


### 2.5 索引的分类
- 单一索引：给单个字段添加索引
- 复合索引: 给多个字段联合起来添加1个索引
- 主键索引：主键上会自动添加索引
- 唯一索引：有unique约束的字段上会自动添加索引




--------------------------------------------------------------------------------


## 3. 视图
- 视图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，java程序员只对视图对象进行CRUD。
- 对视图进行增删改查，会影响到原表数据。
```sql
# 创建视图：
create view myview as select empno,ename from emp;
# 删除视图：
drop view myview;
```



--------------------------------------------------------------------------------

## 4. DBA命令

### 4.1 将数据库当中的数据导出
- 导出整个库：`mysqldump funkytest>~/funkytest.sql -uroot -p333`
- 导出指定数据库当中的指定表：`mysqldump funkytest emp>~/funkytest.sql -uroot –p123`

### 4.2 导入数据
- `create database funkytest;`
- `use funkytest;`
- `source ~/funkytest.sql`

--------------------------------------------------------------------------------

## 5. 数据库设计三范式
- 设计范式：设计表的依据。按照这个三范式设计的表不会出现数据冗余
- 三范式都是哪些
    - 第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。
    - 第二范式：建立在第一范式的基础之上，所有非主键字段完全依赖主键，不能产生部分依赖。（多对多，三张表，关系表两个外键）
    - 第三范式：建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。（一对多，两张表，多的表加外键。）
- 提醒：在实际的开发中，以满足客户的需求为主，有的时候会拿冗余换执行速度。







## 参考
- [MySQL基础入门-mysql教程-数据库实战](https://www.bilibili.com/video/av57575364)