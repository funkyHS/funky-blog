{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{385:function(n,e,t){\"use strict\";t.r(e);var a=t(45),i=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[t(\"p\"),t(\"div\",{staticClass:\"table-of-contents\"},[t(\"ul\",[t(\"li\",[t(\"a\",{attrs:{href:\"#_1-什么是runtime\"}},[n._v(\"1. 什么是runtime\")])]),t(\"li\",[t(\"a\",{attrs:{href:\"#_2-runtime的作用\"}},[n._v(\"2. runtime的作用\")])]),t(\"li\",[t(\"a\",{attrs:{href:\"#_3-runtime常用方法\"}},[n._v(\"3. runtime常用方法\")]),t(\"ul\",[t(\"li\",[t(\"a\",{attrs:{href:\"#发送消息\"}},[n._v(\"发送消息\")])]),t(\"li\",[t(\"a\",{attrs:{href:\"#交换方法\"}},[n._v(\"交换方法\")])]),t(\"li\",[t(\"a\",{attrs:{href:\"#动态添加方法\"}},[n._v(\"动态添加方法\")])]),t(\"li\",[t(\"a\",{attrs:{href:\"#给分类添加属性\"}},[n._v(\"给分类添加属性\")])]),t(\"li\",[t(\"a\",{attrs:{href:\"#字典转模型\"}},[n._v(\"字典转模型\")])])])])])]),t(\"p\"),n._v(\" \"),t(\"h1\",{attrs:{id:\"runtime\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#runtime\"}},[n._v(\"#\")]),n._v(\" Runtime\")]),n._v(\" \"),t(\"p\",[n._v(\"专题链接：https://www.jianshu.com/c/dc947eab6af3\")]),n._v(\" \"),t(\"h2\",{attrs:{id:\"_1-什么是runtime\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-什么是runtime\"}},[n._v(\"#\")]),n._v(\" 1. 什么是runtime\")]),n._v(\" \"),t(\"ul\",[t(\"li\",[n._v(\"RunTime简称运行时。OC就是运行时机制，也就是在运行时候的一些机制，其中最主要的是消息机制。\")]),n._v(\" \"),t(\"li\",[n._v(\"对于C语言，函数的调用在编译的时候会决定调用哪个函数。\")]),n._v(\" \"),t(\"li\",[n._v(\"对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。\")]),n._v(\" \"),t(\"li\",[n._v(\"在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错\")])]),n._v(\" \"),t(\"h2\",{attrs:{id:\"_2-runtime的作用\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-runtime的作用\"}},[n._v(\"#\")]),n._v(\" 2. runtime的作用\")]),n._v(\" \"),t(\"ul\",[t(\"li\",[n._v(\"动态的添加对象的成员变量和方法\")]),n._v(\" \"),t(\"li\",[n._v(\"动态交换两个方法的实现（可以替换系统的方法）\")]),n._v(\" \"),t(\"li\",[n._v(\"获得某个类的所有成员方法、所有成员变量\")]),n._v(\" \"),t(\"li\",[n._v(\"实现分类也可以添加属性\")]),n._v(\" \"),t(\"li\",[n._v(\"实现NSCoding的自动归档和解档\")]),n._v(\" \"),t(\"li\",[n._v(\"实现字典转模型的自动转换\")])]),n._v(\" \"),t(\"h2\",{attrs:{id:\"_3-runtime常用方法\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-runtime常用方法\"}},[n._v(\"#\")]),n._v(\" 3. runtime常用方法\")]),n._v(\" \"),t(\"h3\",{attrs:{id:\"发送消息\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#发送消息\"}},[n._v(\"#\")]),n._v(\" 发送消息\")]),n._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[n._v(\"方法调用的本质，就是让对象发送消息。\")])]),n._v(\" \"),t(\"li\",[t(\"p\",[n._v(\"objc_msgSend,只有对象才能发送消息，因此以objc开头.\")])]),n._v(\" \"),t(\"li\",[t(\"p\",[n._v(\"使用\"),t(\"code\",[n._v(\"消息机制\")]),n._v(\"前提，必须导入#import <objc/message.h>\")])]),n._v(\" \"),t(\"li\",[t(\"p\",[n._v(\"消息机制简单使用\")])])]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"\\n \\t// 创建person对象\\n\\n    Person *p = [[Person alloc] init];\\n\\n    \\n\\n    // 调用对象方法\\n\\n    [p eat];\\n\\n    \\n\\n    // 本质：让对象发送消息\\n\\n    objc_msgSend(p, @selector(eat));\\n\\n\\n\\n    // 调用类方法的方式：两种\\n\\n    // 第一种通过类名调用\\n\\n    [Person eat];\\n\\n    // 第二种通过类对象调用\\n\\n    [[Person class] eat];\\n\\n    \\n\\n    // 用类名调用类方法，底层会自动把类名转换成类对象调用\\n\\n    // 本质：让类对象发送消息\\n\\n    objc_msgSend([Person class], @selector(eat));\\n\\n\")])])]),t(\"ul\",[t(\"li\",[t(\"p\",[n._v(\"消息机制原理:对象根据方法编号SEL去映射表查找对应的方法实现\")])]),n._v(\" \"),t(\"li\",[t(\"p\",[t(\"img\",{attrs:{src:\"Snip20151013_4.png\",alt:\"\"}})])])]),n._v(\" \"),t(\"h3\",{attrs:{id:\"交换方法\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#交换方法\"}},[n._v(\"#\")]),n._v(\" 交换方法\")]),n._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[n._v(\"开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。\")])]),n._v(\" \"),t(\"li\",[t(\"p\",[n._v(\"方式一:继承系统的类，重写方法.\")])]),n._v(\" \"),t(\"li\",[t(\"p\",[n._v(\"方式二:使用runtime,交换方法.\")])])]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('\\n@implementation ViewController\\n\\n- (void)viewDidLoad {\\n\\n    [super viewDidLoad];\\n\\n    // Do any additional setup after loading the view, typically from a nib.\\n\\n    // 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。\\n\\n    // 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name;\\n\\n    // 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。\\n\\n    UIImage *image = [UIImage imageNamed:@\"123\"];    \\n\\n}\\n\\n@end\\n\\n\\n\\n@implementation UIImage (Image)\\n\\n// 加载分类到内存的时候调用\\n\\n+ (void)load\\n\\n{\\n\\n    // 交换方法\\n\\n    \\n\\n    // 获取imageWithName方法地址\\n\\n    Method imageWithName = class_getClassMethod(self, @selector(imageWithName:));\\n\\n    \\n\\n    // 获取imageWithName方法地址\\n\\n    Method imageName = class_getClassMethod(self, @selector(imageNamed:));\\n\\n\\n\\n    // 交换方法地址，相当于交换实现方式\\n\\n    method_exchangeImplementations(imageWithName, imageName);\\n\\n}\\n\\n\\n\\n// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.\\n\\n\\n\\n// 既能加载图片又能打印\\n\\n+ (instancetype)imageWithName:(NSString *)name\\n\\n{\\n\\n    // 这里调用imageWithName，相当于调用imageName\\n\\n    UIImage *image = [self imageWithName:name];\\n\\n    if (image == nil) {\\n\\n        NSLog(@\"加载空的图片\");\\n\\n    }\\n\\n    return image;\\n\\n}\\n\\n@end\\n\\n')])])]),t(\"ul\",[t(\"li\",[t(\"p\",[n._v(\"交换原理：\")])]),n._v(\" \"),t(\"li\",[t(\"p\",[n._v(\"交换之前：\")])])]),n._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"Snip20151013_2.png\",alt:\"\"}})]),n._v(\" \"),t(\"ul\",[t(\"li\",[n._v(\"交换之后：\")])]),n._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"Snip20151013_3.png\",alt:\"\"}})]),n._v(\" \"),t(\"h3\",{attrs:{id:\"动态添加方法\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#动态添加方法\"}},[n._v(\"#\")]),n._v(\" 动态添加方法\")]),n._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[n._v(\"开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。\")])]),n._v(\" \"),t(\"li\",[t(\"p\",[n._v(\"经典面试题：有没有使用performSelector，其实主要想问你有没有动态添加过方法。\")])]),n._v(\" \"),t(\"li\",[t(\"p\",[n._v(\"简单使用\")])])]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('\\n@implementation ViewController\\n\\n\\n\\n- (void)viewDidLoad {\\n\\n    [super viewDidLoad];    \\n\\n    Person *p = [[Person alloc] init];\\n\\n    // 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。\\n\\n    // 动态添加方法就不会报错\\n\\n    [p performSelector:@selector(eat)];\\n\\n}\\n\\n@end\\n\\n\\n\\n@implementation Person\\n\\n// void(*)()\\n\\n// 默认方法都有两个隐式参数，\\n\\nvoid eat(id self,SEL sel)\\n\\n{\\n\\n    NSLog(@\"%@ %@\",self,NSStringFromSelector(sel));\\n\\n}\\n\\n\\n\\n// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.\\n\\n// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法\\n\\n+ (BOOL)resolveInstanceMethod:(SEL)sel\\n\\n{\\n\\n    if (sel == @selector(eat)) {\\n\\n        // 动态添加eat方法\\n\\n        \\n\\n        // 第一个参数：给哪个类添加方法\\n\\n        // 第二个参数：添加方法的方法编号\\n\\n        // 第三个参数：添加方法的函数实现（函数地址）\\n\\n        // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象->self :表示SEL->_cmd\\n\\n        class_addMethod(self, @selector(eat), eat, \"v@:\");\\n\\n    }\\n\\n    return [super resolveInstanceMethod:sel];\\n\\n}\\n\\n@end\\n\\n')])])]),t(\"h3\",{attrs:{id:\"给分类添加属性\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#给分类添加属性\"}},[n._v(\"#\")]),n._v(\" 给分类添加属性\")]),n._v(\" \"),t(\"ul\",[t(\"li\",[n._v(\"原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。\")])]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('\\n@implementation ViewController\\n\\n- (void)viewDidLoad {\\n\\n    [super viewDidLoad];\\n\\n    // 给系统NSObject类动态添加属性name\\n\\n    NSObject *objc = [[NSObject alloc] init];\\n\\n    objc.name = @\"小码哥\";\\n\\n    NSLog(@\"%@\",objc.name);\\n\\n}\\n\\n@end\\n\\n\\n\\n\\n\\n// 定义关联的key\\n\\nstatic const char *key = \"name\";\\n\\n@implementation NSObject (Property)\\n\\n- (NSString *)name\\n\\n{\\n\\n    // 根据关联的key，获取关联的值。\\n\\n    return objc_getAssociatedObject(self, key);\\n\\n}\\n\\n\\n\\n- (void)setName:(NSString *)name\\n\\n{\\n\\n    // 第一个参数：给哪个对象添加关联\\n\\n    // 第二个参数：关联的key，通过这个key获取\\n\\n    // 第三个参数：关联的value\\n\\n    // 第四个参数:关联的策略\\n\\n    objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\\n\\n}\\n\\n@end\\n\\n')])])]),t(\"h3\",{attrs:{id:\"字典转模型\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#字典转模型\"}},[n._v(\"#\")]),n._v(\" 字典转模型\")]),n._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[n._v(\"设计模型：字典转模型的第一步\")])]),n._v(\" \"),t(\"li\",[t(\"p\",[n._v(\"模型属性，通常需要跟字典中的key一一对应\")])]),n._v(\" \"),t(\"li\",[t(\"p\",[n._v(\"问题：一个一个的生成模型属性，很慢？\")])]),n._v(\" \"),t(\"li\",[t(\"p\",[n._v(\"需求：能不能自动根据一个字典，生成对应的属性。\")])]),n._v(\" \"),t(\"li\",[t(\"p\",[n._v(\"解决：提供一个分类，专门根据字典生成对应的属性字符串。\")])])]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('\\n@implementation NSObject (Log)\\n\\n\\n\\n\\n\\n// 自动打印属性字符串\\n\\n+ (void)resolveDict:(NSDictionary *)dict{\\n\\n\\n\\n    // 拼接属性字符串代码\\n\\n    NSMutableString *strM = [NSMutableString string];\\n\\n    \\n\\n    // 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码\\n\\n    [dict enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\\n\\n        \\n\\n        // 类型经常变，抽出来\\n\\n         NSString *type;\\n\\n        \\n\\n        if ([obj isKindOfClass:NSClassFromString(@\"__NSCFString\")]) {\\n\\n            type = @\"NSString\";\\n\\n        }else if ([obj isKindOfClass:NSClassFromString(@\"__NSCFArray\")]){\\n\\n            type = @\"NSArray\";\\n\\n        }else if ([obj isKindOfClass:NSClassFromString(@\"__NSCFNumber\")]){\\n\\n            type = @\"int\";\\n\\n        }else if ([obj isKindOfClass:NSClassFromString(@\"__NSCFDictionary\")]){\\n\\n            type = @\"NSDictionary\";\\n\\n        }\\n\\n\\n\\n        \\n\\n        // 属性字符串\\n\\n        NSString *str;\\n\\n        if ([type containsString:@\"NS\"]) {\\n\\n            str = [NSString stringWithFormat:@\"@property (nonatomic, strong) %@ *%@;\",type,key];\\n\\n        }else{\\n\\n            str = [NSString stringWithFormat:@\"@property (nonatomic, assign) %@ %@;\",type,key];\\n\\n        }\\n\\n        \\n\\n        // 每生成属性字符串，就自动换行。\\n\\n        [strM appendFormat:@\"\\\\n%@\\\\n\",str];\\n\\n        \\n\\n    }];\\n\\n    \\n\\n    // 把拼接好的字符串打印出来，就好了。\\n\\n    NSLog(@\"%@\",strM);\\n\\n}\\n\\n@end\\n\\n')])])]),t(\"ul\",[t(\"li\",[n._v(\"字典转模型的方式一：KVC\")])]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"\\n@implementation Status\\n\\n+ (instancetype)statusWithDict:(NSDictionary *)dict\\n\\n{\\n\\n    Status *status = [[self alloc] init];\\n\\n    [status setValuesForKeysWithDictionary:dict];\\n\\n    return status;\\n\\n}\\n\\n@end\\n\\n\")])])]),t(\"ul\",[t(\"li\",[t(\"p\",[n._v(\"KVC字典转模型弊端：必须保证，模型中的属性和字典中的key一一对应。\")])]),n._v(\" \"),t(\"li\",[t(\"p\",[n._v(\"如果不一致，就会调用\"),t(\"code\",[n._v(\"[<Status 0x7fa74b545d60> setValue:forUndefinedKey:]\")])])])]),n._v(\" \"),t(\"p\",[n._v(\"报\"),t(\"code\",[n._v(\"key\")]),n._v(\"找不到的错。\")]),n._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[n._v(\"分析:模型中的属性和字典的key不一一对应，系统就会调用\"),t(\"code\",[n._v(\"setValue:forUndefinedKey:\")]),n._v(\"报错。\")])]),n._v(\" \"),t(\"li\",[t(\"p\",[n._v(\"解决:重写对象的\"),t(\"code\",[n._v(\"setValue:forUndefinedKey:\")]),n._v(\",把系统的方法覆盖，\")])])]),n._v(\" \"),t(\"p\",[n._v(\"就能继续使用KVC，字典转模型了。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"\\n- (void)setValue:(id)value forUndefinedKey:(NSString *)key\\n\\n{\\n\\n}\\n\\n\")])])]),t(\"ul\",[t(\"li\",[t(\"p\",[n._v(\"字典转模型的方式二：Runtime\")])]),n._v(\" \"),t(\"li\",[t(\"p\",[n._v(\"思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。\")])]),n._v(\" \"),t(\"li\",[t(\"p\",[n._v(\"步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。\")])])]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('\\n@implementation ViewController\\n\\n- (void)viewDidLoad {\\n\\n    [super viewDidLoad];    \\n\\n    // 解析Plist文件\\n\\n    NSString *filePath = [[NSBundle mainBundle] pathForResource:@\"status.plist\" ofType:nil];\\n\\n   NSDictionary *statusDict = [NSDictionary dictionaryWithContentsOfFile:filePath];\\n\\n    // 获取字典数组\\n\\n    NSArray *dictArr = statusDict[@\"statuses\"];\\n\\n    // 自动生成模型的属性字符串\\n\\n//    [NSObject resolveDict:dictArr[0][@\"user\"]];\\n\\n    _statuses = [NSMutableArray array];\\n\\n    // 遍历字典数组\\n\\n    for (NSDictionary *dict in dictArr) {\\n\\n        Status *status = [Status modelWithDict:dict];\\n\\n        [_statuses addObject:status];\\n\\n    }\\n\\n    // 测试数据\\n\\n    NSLog(@\"%@ %@\",_statuses,[_statuses[0] user]);    \\n\\n}\\n\\n\\n\\n@end\\n\\n\\n\\n@implementation NSObject (Model)\\n\\n\\n\\n+ (instancetype)modelWithDict:(NSDictionary *)dict\\n\\n{\\n\\n    // 思路：遍历模型中所有属性-》使用运行时\\n\\n    \\n\\n    // 0.创建对应的对象\\n\\n    id objc = [[self alloc] init];\\n\\n    \\n\\n    // 1.利用runtime给对象中的成员属性赋值\\n\\n    \\n\\n    // class_copyIvarList:获取类中的所有成员属性\\n\\n    // Ivar：成员属性的意思\\n\\n    // 第一个参数：表示获取哪个类中的成员属性\\n\\n    // 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值\\n\\n    // 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。\\n\\n    /* 类似下面这种写法\\n\\n     \\n\\n     Ivar ivar;\\n\\n     Ivar ivar1;\\n\\n     Ivar ivar2;\\n\\n     // 定义一个ivar的数组a\\n\\n     Ivar a[] = {ivar,ivar1,ivar2};\\n\\n     \\n\\n     // 用一个Ivar *指针指向数组第一个元素\\n\\n     Ivar *ivarList = a;\\n\\n     \\n\\n     // 根据指针访问数组第一个元素\\n\\n     ivarList[0];\\n\\n     \\n\\n     */\\n\\n    unsigned int count;\\n\\n    \\n\\n    // 获取类中的所有成员属性\\n\\n    Ivar *ivarList = class_copyIvarList(self, &count);\\n\\n    \\n\\n    for (int i = 0; i < count; i++) {\\n\\n        // 根据角标，从数组取出对应的成员属性\\n\\n        Ivar ivar = ivarList[i];\\n\\n        \\n\\n        // 获取成员属性名\\n\\n        NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)];\\n\\n        \\n\\n        // 处理成员属性名->字典中的key\\n\\n        // 从第一个角标开始截取\\n\\n        NSString *key = [name substringFromIndex:1];\\n\\n\\n\\n        // 根据成员属性名去字典中查找对应的value\\n\\n        id value = dict[key];\\n\\n        \\n\\n        // 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型\\n\\n        // 判断下value是否是字典\\n\\n        if ([value isKindOfClass:[NSDictionary class]]) {\\n\\n            // 字典转模型\\n\\n            // 获取模型的类对象，调用modelWithDict\\n\\n            // 模型的类名已知，就是成员属性的类型\\n\\n            \\n\\n            // 获取成员属性类型\\n\\n           NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];\\n\\n          // 生成的是这种@\"@\\\\\"User\\\\\"\" 类型 -》 @\"User\"  在OC字符串中 \\\\\" -> \"，\\\\是转义的意思，不占用字符\\n\\n            // 裁剪类型字符串\\n\\n            NSRange range = [type rangeOfString:@\"\\\\\"\"];\\n\\n\\n\\n           type = [type substringFromIndex:range.location + range.length];\\n\\n            \\n\\n            range = [type rangeOfString:@\"\\\\\"\"];\\n\\n            \\n\\n            // 裁剪到哪个角标，不包括当前角标\\n\\n          type = [type substringToIndex:range.location];\\n\\n\\n\\n            \\n\\n            // 根据字符串类名生成类对象\\n\\n            Class modelClass = NSClassFromString(type);\\n\\n            \\n\\n\\n\\n            if (modelClass) { // 有对应的模型才需要转\\n\\n                \\n\\n                // 把字典转模型\\n\\n                value  =  [modelClass modelWithDict:value];\\n\\n            }\\n\\n            \\n\\n            \\n\\n        }\\n\\n        \\n\\n        // 三级转换：NSArray中也是字典，把数组中的字典转换成模型.\\n\\n        // 判断值是否是数组\\n\\n        if ([value isKindOfClass:[NSArray class]]) {\\n\\n            // 判断对应类有没有实现字典数组转模型数组的协议\\n\\n            if ([self respondsToSelector:@selector(arrayContainModelClass)]) {\\n\\n                \\n\\n                // 转换成id类型，就能调用任何对象的方法\\n\\n                id idSelf = self;\\n\\n                \\n\\n                // 获取数组中字典对应的模型\\n\\n                NSString *type =  [idSelf arrayContainModelClass][key];\\n\\n                \\n\\n                // 生成模型\\n\\n               Class classModel = NSClassFromString(type);\\n\\n                NSMutableArray *arrM = [NSMutableArray array];\\n\\n                // 遍历字典数组，生成模型数组\\n\\n                for (NSDictionary *dict in value) {\\n\\n                    // 字典转模型\\n\\n                  id model =  [classModel modelWithDict:dict];\\n\\n                    [arrM addObject:model];\\n\\n                }\\n\\n                \\n\\n                // 把模型数组赋值给value\\n\\n                value = arrM;\\n\\n            }\\n\\n        }\\n\\n        if (value) { // 有值，才需要给模型的属性赋值\\n\\n            // 利用KVC给模型中的属性赋值\\n\\n            [objc setValue:value forKey:key];\\n\\n        }\\n\\n    }\\n\\n    return objc;\\n\\n}\\n\\n@end\\n\\n')])])])])}),[],!1,null,null,null);e.default=i.exports}}]);","extractedComments":[]}